# 1 介绍一下并发与并行

## 1.1 概念

- 并发（Concurrency）：是指两个或多个任务在同一时间间隔内发生。这意味着这些任务在宏观上看似同时执行，但在微观上，由于CPU调度的原因，它们是交替执行的。并发更多地涉及到任务之间的切换和协作。
- 并行（Parallelism）：是指两个或多个任务在同一时刻同时发生。在并行计算中，多个任务在多个处理器或多核CPU上同时执行，这可以大大提高程序的执行效率。

## 1.2 执行方式

- 并发：在单处理器系统中，并发是通过时间片轮转的方式实现的，即多个任务被快速地轮换执行，使得在宏观上具有多个任务同时执行的效果。而在多处理器系统中，并发任务也可以被分配到不同的处理器上执行。
- 并行：在多处理器或多核CPU系统中，并行要求程序能够同时执行多个操作，每个任务都在其专用的处理器或核心上执行。

## 1.3 依赖资源

- 并发：在单处理器和多处理器系统中都存在。在单处理器系统中，并发通过CPU的快速切换来模拟多个任务同时执行的效果，而实际上在同一时刻只有一个任务在执行。
- 并行：并行通常只在多处理器或多核CPU系统中存在，因为它要求同时执行多个任务。

## 1.4 效率

- 并发：由于任务之间需要切换，因此并发执行可能会导致一定的效率损失。但是，它可以通过合理的任务调度和协作来平衡资源使用，提高系统的整体效率。
- 并行：由于多个任务同时执行，因此并行通常可以大大提高程序的执行效率。但是，它也需要更多的硬件资源来支持。

# 2 同步和异步的区别

## 2.1 执行方式

- 同步：同步是一种阻塞式的操作方式，即当一个任务需要等待另一个任务完成时，发起任务的线程会一直处于等待状态，直到被等待的任务完成。在此期间，发起任务的线程无法继续执行其他任务。
- 异步：异步是一种非阻塞式的操作方式，即当一个任务需要等待另一个任务完成时，发起任务的线程不会一直等待，而是可以继续执行其他任务。被等待的任务完成后，会通过回调函数或其他机制通知发起任务的线程。

## 2.2 效率

- 同步：由于发起任务的线程在等待过程中无法执行其他任务，因此同步操作可能会导致线程资源的浪费，降低系统的整体效率。
- 异步：由于发起任务的线程在等待过程中可以继续执行其他任务，因此异步操作可以充分利用线程资源，提高系统的整体效率。

# 3 进程和线程区别

进程（Process）和线程（Thread）是操作系统管理程序执行的基本单元，它们既有联系又有显著区别。

| **特性**     | **进程**                                         | **线程**                                         |
| :----------- | :----------------------------------------------- | :----------------------------------------------- |
| **定义**     | 资源分配的基本单位，独立运行的程序实例           | CPU调度的基本单位，进程内的执行单元              |
| **资源隔离** | 每个进程有独立的内存空间和系统资源（如文件句柄） | 同一进程内的线程共享内存和资源                   |
| **创建开销** | 高（需分配独立资源）                             | 低（共享进程资源）                               |
| **通信方式** | 进程间通信（IPC），如管道、消息队列、共享内存    | 直接读写共享内存（需同步机制）                   |
| **独立性**   | 进程间相互独立，一个进程崩溃不影响其他进程       | 线程间相互影响，一个线程崩溃可能导致整个进程终止 |
| **切换开销** | 高（需切换内存空间、寄存器等）                   | 低（仅切换线程上下文）                           |
| **并发性**   | 多进程可并行（多核）                             | 多线程可并行（多核）或并发（单核）               |

从上述可知，线程是进程的一个执行单元，是进程的可调度实体。一个进程可以包含多个线程，每个线程都是进程的一个执行单元。线程共享进程的资源，如内存、I/O和CPU等，但每个线程有自己的堆栈和局部变量。

# 4 单核 CPU 上运行多个线程效率一定会高吗

在单核CPU上运行多个线程，效率不一定会高。这是因为单核CPU在同一时间只能执行一个线程，因此多线程的执行实际上是通过时间片轮转的方式实现的，即多个线程交替执行。这种交替执行的方式会导致线程切换的开销，包括保存和恢复线程上下文、CPU缓存失效等，从而影响程序的执行效率。此外，单核CPU上的多线程执行还受到线程调度算法的影响。如果线程调度算法不合理，可能会导致线程频繁切换，进一步降低程序的执行效率。

然而，在某些情况下，单核CPU上的多线程执行仍然是有用的。例如，当一个线程需要等待I/O操作完成时，可以让另一个线程继续执行计算任务，从而充分利用CPU资源。此外，多线程也可以提高程序的响应能力，使得用户界面更加流畅。因此，在单核CPU上运行多个线程是否高效，取决于具体的应用场景和线程调度策略。在实际应用中，需要根据具体情况来选择合适的线程使用策略。

# 5 使用多线程可能带来什么问题?

使用多线程编程可以带来许多好处，但同时也可能引入一些问题和挑战。以下是一些常见的问题：

1. **线程安全性**：多线程环境中，多个线程可能同时访问和修改共享数据，导致数据的不一致性。这称为线程安全问题。为了解决线程安全问题，需要采取适当的同步措施，如使用锁、信号量等。
2. **性能开销**：创建和销毁线程需要一定的时间和空间开销。如果线程数量过多，会导致系统资源的浪费和性能的下降。此外，线程间的上下文切换也会导致额外的开销。
3. **死锁**：当多个线程相互等待对方释放资源时，可能发生死锁。死锁会导致线程无法继续执行，从而影响程序的正常运行。避免死锁的方法包括使用锁顺序、设置超时时间等。
4. **活锁和饥饿**：活锁是指线程不断地尝试获取资源或执行操作，但由于竞争条件或其他原因，始终无法成功。饥饿是指某些线程长时间得不到执行的机会，而其他线程却能频繁执行。这些问题可能导致程序的性能下降或不稳定。
5. **线程通信和同步的复杂性**：线程间的通信和同步是多线程编程的关键问题。需要使用适当的机制（如消息传递、共享内存等）来实现线程间的协作和同步。然而，这些机制的实现可能非常复杂，并容易引入错误。

为了解决上述问题，程序员需要采取一系列措施，如合理设计线程数量、使用适当的同步机制、避免死锁等。此外，还可以使用一些高级的多线程编程技术，如线程池、异步编程模型等，来简化多线程编程的复杂性并提高程序的性能。

# 6 什么是线程上下文切换?

线程上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个线程切换到另一个线程的过程。上下文是指某一时间点 CPU 寄存器和程序计数器的内容。寄存器是 CPU 内部的少量、速度极快的存储设备，用于存储和访问计算过程中的中间值，以加快计算机程序的运行速度。程序计数器则保存着接下来要执行的指令的地址。

在进行线程上下文切换时，系统需要保存当前线程的上下文（即 CPU 寄存器和程序计数器的状态），然后恢复下一个要执行的线程的上下文。这个过程涉及保存和恢复大量的状态信息，因此上下文切换是一个相对昂贵的操作，会消耗大量的 CPU 时间。

线程上下文切换通常发生在以下情况：

1. 当前线程的时间片用完，操作系统需要将 CPU 的使用权切换到下一个线程。
2. 当前线程主动放弃 CPU 的使用权，例如调用了某些会导致线程阻塞的系统调用（如 I/O 操作）。
3. 当前线程因为某些原因（如发生异常）被操作系统强制终止。

虽然多线程可以提高程序的执行效率，但由于线程上下文切换的开销，线程数量并不是越多越好。因此，在进行多线程编程时，需要权衡线程数量、任务划分以及上下文切换带来的开销，以达到最佳的性能表现。

# 7 如何理解线程安全和不安全？

线程安全和多线程访问时的加锁机制紧密相关。当一个线程访问某个类的数据时，如果采用了加锁机制，其他线程就不能访问这个数据，直到该线程读取完毕。这种机制确保了数据的一致性和完整性，不会出现数据不一致或数据污染的情况，这就是线程安全。

相反，线程不安全是指不提供数据访问保护，也就是说，当多个线程同时访问和修改共享数据时，可能会引发数据不一致或其他不可预期的结果。这通常是因为没有采取适当的同步措施，导致线程间的竞争条件或数据冲突。

在实际编程中，线程安全和不安全的问题通常是由全局变量和静态变量引起的。如果每个线程中对这些变量只有读操作而没有写操作，那么一般来说，这些变量是线程安全的。但是，如果有多个线程同时对全局变量或静态变量进行写操作，那么就需要考虑线程同步的问题，否则可能会导致线程不安全。

因此，为了确保线程安全，程序员需要采取一系列措施，如使用锁、信号量等同步机制，以及合理设计线程数量和通信方式，避免死锁和饥饿等问题。同时，也需要注意避免在代码中引入线程不安全的操作，如直接访问和修改共享数据等。

# 8 什么是CAS

CAS是**Compare and Swap的缩写，直译为“比较并交换”**。CAS是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。

CAS操作包含三个操作数——内存位置（V）、预期原值（A）和更新值（B）。执行CAS操作时，会将内存位置V的值与预期原值A进行比较。如果相匹配，那么处理器会自动将该内存位置V的值更新为B。如果不相匹配，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。这一过程是原子的，也就是说CAS指令在执行期间不会被其他线程打断。

CAS的主要优势在于它是一种无锁机制，可以避免使用传统锁所带来的性能开销和死锁问题。在多线程并发编程中，CAS被广泛应用于实现无锁数据结构、原子变量等操作。
