# 1 介绍volatile

在Java中，`volatile`是一个轻量级的线程同步关键字，主要用于解决多线程环境下的**内存可见性**和**指令重排序**问题。以下是其核心特性和应用场景：

**1. 内存可见性（Visibility）**

- **问题**：线程操作变量时，会将数据从主内存拷贝到线程的工作内存（缓存）。普通变量修改后可能不会立即写回主内存，导致其他线程读取到旧值。
- **作用**：
  - `volatile`修饰的变量修改后，会**强制立即写回主内存**。
  - 其他线程读取该变量时，会**强制从主内存重新加载最新值**。

```java
volatile boolean flag = false;

// 线程A
flag = true; // 修改后立即同步到主内存

// 线程B
while (!flag) { // 每次循环都会从主内存重新读取flag
    // 等待
}
```

**2.禁止指令重排序（Ordering）**

- 问题：JVM和CPU为了优化性能，可能对指令进行重排序（在不改变单线程语义的前提下）。

- 作用：

  - `volatile`通过插入**内存屏障**（Memory Barrier），禁止编译器和处理器对指令进行重排序。
  - 确保写操作前的指令不会重排序到写操作之后，读操作后的指令不会重排序到读操作之前。

- **经典场景**：单例模式的双重检查锁（Double-Checked Locking）。

  ```java
  class Singleton {
      private static volatile Singleton instance;
  
      public static Singleton getInstance() {
          if (instance == null) {                     // 第一次检查
              synchronized (Singleton.class) {
                  if (instance == null) {              // 第二次检查
                      instance = new Singleton();      // volatile禁止指令重排序
                  }
              }
          }
          return instance;
      }
  }
  ```

**3.volatile的局限性**

- 不保证原子性：
  - `volatile`只能保证单次读/写操作的原子性，但无法保证复合操作（如i++）的原子性。
  - 示例：两个线程同时执行i++（实际是read-modify-write三步操作），可能导致结果错误。
  - 解决方案：使用`synchronized`或原子类（如AtomicInteger）。

**4. 适用场景**

1. **状态标志**：

   ```java
   volatile boolean shutdownRequested;
   
   public void shutdown() {
       shutdownRequested = true;
   }
   
   public void doWork() {
       while (!shutdownRequested) {
           // 执行任务
       }
   }
   ```

   > 注意该状态标志位，主要是一个线程负责写，其它线程负责读取，或者多个线程负责同时写，但是写的状态结果是一样的。

2. **单次安全发布**（如单例模式）。

3. **独立观察变量**（如定期更新某个值供其他线程读取）。

**5.实现原理**

- 内存屏障：
  - 写操作：在写`volatile`变量前插入StoreStore屏障，写后插入StoreLoad屏障。
  - 读操作：在读volatile变量前插入LoadLoad屏障，读后插入LoadStore屏障。

- 底层实现：依赖CPU的MESI协议（缓存一致性协议）。

**6. volatile vs synchronized**

| **特性**     | **volatile**           | **synchronized**                 |
| :----------- | :--------------------- | :------------------------------- |
| **原子性**   | 不保证复合操作的原子性 | 保证代码块/方法的原子性          |
| **可见性**   | 直接可见               | 通过锁的释放和获取间接保证       |
| **有序性**   | 禁止指令重排序         | 通过锁的互斥性保证有序性         |
| **性能**     | 轻量级（无上下文切换） | 重量级（涉及锁竞争和上下文切换） |
| **适用场景** | 状态标志、单次发布     | 需要原子性保证的复合操作         |

`volatile` 是 Java 虚拟机（JVM）提供的一种轻量级的同步机制，用于确保多线程环境下变量的可见性和有序性。当一个变量被声明为 `volatile` 时，JVM 会尽力保证所有线程看到这个变量的值是一致的。

> 在多线程场景下，如果一个线程正在修改 `volatile` 变量，另一个线程同时读取该变量，**结果一定是确定的**：**读线程要么读到修改前的旧值，要么读到修改后的新值**，但绝不会读到“中间状态”或“不一致”的值。



# 2 Synchronized

Synchronized是Java中的一个关键字，用于解决并发问题。它的原理和应用场景如下：

**原理**：

1. **基于JVM内置锁**：Synchronized的实现依赖于JVM的内置锁，即对象监视器（Object Monitor）。每个对象都有一个监视器与之关联，当线程尝试获取对象的锁时，会进入监视器。
2. **重量级锁**：在JDK 1.6之前，Synchronized是一个重量级锁，其性能相对较低。然而，从JDK 1.6开始，对其进行了优化升级，引入了偏向锁、轻量级锁等机制，以减少锁的开销，提高其性能。
3. **原子性、可见性和有序性**：Synchronized保证了线程互斥地访问同步代码，确保了对共享变量的修改能够及时可见，并解决了重排序问题。

**应用场景**：

1. **同步代码块**：当需要同步访问某个代码块时，可以使用Synchronized关键字来修饰该代码块。例如，当一个线程需要访问共享资源时，可以使用Synchronized代码块来确保在同一时间只有一个线程能够访问该资源。
2. **同步方法**：除了同步代码块，Synchronized还可以用于修饰方法。当修饰非静态方法时，它锁住的是当前实例；当修饰静态方法时，它锁住的是整个类。

需要注意的是，虽然Synchronized在解决并发问题方面非常有用，但过度使用可能导致性能问题。因此，在设计和实现多线程程序时，应根据具体的应用需求和场景来权衡是否使用Synchronized。

再次回到就绪状态。最终，当线程执行完毕或被提前终止时，它将进入死亡状态，并释放其占用的资源。

**作用范围**

Synchronized的作用范围主要分为两大类：类锁和对象锁。

1. 类锁：当`synchronized`作用于静态方法或静态代码块时，锁住的是Class实例，也就是类的元信息。因为静态方法属于类而不属于对象，所以类锁相当于类的一个全局锁，会锁所有调用该方法的线程。这种锁机制可以确保同一时刻只有一个线程能够执行静态方法或静态代码块，从而避免多个线程同时访问共享资源导致的数据不一致问题。
2. 对象锁：当synchronized作用于非静态方法或非静态代码块时，锁住的是对象的实例，即this对象。这种锁机制可以确保同一时刻只有一个线程能够访问该对象的非静态方法或非静态代码块，从而避免多个线程同时访问同一对象的共享资源导致的数据不一致问题。

需要注意的是，类锁和对象锁是两种不同的锁机制，它们之间不会相互干扰。也就是说，一个线程持有对象的锁并不会影响其他线程获取类锁，反之亦然。因此，在设计和实现多线程程序时，需要根据具体的应用需求和场景来选择合适的锁机制。

此外，synchronized是独占式的悲观锁，同时也是可重入锁。这意味着当一个线程持有一个对象的锁时，其他线程无法同时访问该对象的同步代码块或同步方法，从而保证了线程安全。同时，由于synchronized是可重入锁，所以同一个线程可以多次获取同一个对象的锁，而不会出现死锁的情况。

总的来说，synchronized的作用范围取决于它是作用于静态方法还是非静态方法，以及是作用于代码块还是整个方法。不同的作用范围会导致锁定的对象不同，从而实现不同的线程同步效果。