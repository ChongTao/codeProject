# 1 介绍一下JMM

JMM，即Java内存模型（Java Memory Model），是一种抽象的概念，用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

具体来说，JMM定义了程序中各个变量的访问方式，包括如何在多线程环境中安全地访问和修改共享变量。它规定了所有的变量都存储在主内存中，包括实例变量和静态变量（但不包括局部变量和方法参数）。主内存被所有线程共享，但线程对变量的操作都在各自的工作内存中进行。这里的工作内存并不是真实存在的一块内存，而是JMM的一个抽象，它代表了寄存器、一级缓存、二级缓存等的抽象。

JMM解决了CPU多级缓存、处理器优化、指令重排等导致的结果不可预期的问题。它定义了主内存与工作内存之间的交互规则，包括变量的读写、同步操作等，以确保线程间的内存访问操作能够正确、有序地执行。

JMM的主要目标是提供一套规范，让各个JVM的实现来遵守这些规范，以便开发者能够利用这些规范，更方便地开发多线程程序。这样，即便同一个程序在不同的虚拟机上运行，得到的程序结果也是一致的。

总的来说，JMM是Java并发编程中的重要概念，它保证了多线程程序中的内存访问操作的正确性、原子性、可见性和有序性。

# 2 JMM三大特性

JMM（Java内存模型）的三大特性包括原子性、可见性和有序性。

1. **原子性**：原子性是指一个或多个操作要么全部执行并且在执行过程中不会被其他因素打断，要么就都不执行。在Java中，基本数据类型的访问读写是具备原子性的，但是对于更大的数据类型，如long和double，它们的读写操作可能会被划分为两次32位的操作，这时候就需要使用synchronized关键字或者lock体系来保证原子性。此外，JMM还通过CAS（Compare-And-Swap）操作来保证原子性，这是一种由硬件支持的原子操作。
2. **可见性**（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。在并发编程中，由于每个线程都有自己的工作内存，它们可能从主内存中拷贝共享变量的副本到自己的工作内存中进行操作，这就可能导致一个线程修改了共享变量的值，但其他线程却看不到这个修改。为了解决这个问题，JMM提供了volatile关键字和synchronized关键字来保证可见性。当一个共享变量被volatile修饰时，它的读写操作就会具有可见性，即当一个线程修改了它的值，这个修改会立即同步到主内存，其他线程会立即看到这个修改。
3. **有序性**：有序性是指在本线程内观察，所有的操作都是有序的，即按照代码的顺序执行。但是，在并发编程中，由于指令重排序和工作内存与主内存同步延迟等现象，可能会导致指令的执行顺序与预期不符。为了解决这个问题，JMM提供了happens-before原则来保证有序性。这个原则规定了一些操作之间的执行顺序，比如一个线程中的每个操作都happens-before于该线程的解锁操作，以及一个线程对某个变量的解锁操作happens-before于后续对这个变量的加锁操作等。

# 3 as-if-serial和happens-before介绍

在并发编程中，**as-if-serial**和**happens-before**是Java内存模型（JMM）中两个关键概念，分别用于描述程序的**执行顺序**和**内存可见性**规则。

## 3.1 as-if-serial

无论编译器和处理器如何优化（如指令重排序），单线程程序的执行结果必须与代码顺序执行的结果一致。在保证单线程程序正确性的前提下，允许编译器和硬件进行性能优化。

**特点**

- **单线程视角**：只关注单线程内的执行结果正确性，不涉及多线程之间的交互。
- **允许重排序**：若两个操作不存在数据依赖，编译器和处理器可以重排序，但结果必须与顺序执行一致。

```java
int a = 1;      // 操作1
int b = 2;      // 操作2
int c = a + b;  // 操作3
```

## 3.2 happens-before

在多线程环境下，如果一个操作happens-before另一个操作，那么前者的执行结果对后者可见。定义多线程之间的内存可见性规则，避免出现不可预测的结果。

**JMM定义的happens-before规则**

- 程序顺序规则：单线程中的每个操作按代码顺序happens-before后续操作。

- 锁规则：解锁（unlock）操作happens-before后续的加锁（lock）操作。


- volatile变量规则：写volatile变量happens-before后续读该变量。


- 线程启动规则：线程的start()方法happens-before该线程的任何操作。


- 线程终止规则：线程的所有操作happens-before其他线程检测到该线程终止（如Thread.join()）。


- 传递性：若A happens-before B，B happens-before C，则A happens-before C。

## 3.3 两者区别

| **特性**       | **as-if-serial**                             | **happens-before**                 |
| :------------- | :------------------------------------------- | :--------------------------------- |
| **适用场景**   | 单线程程序                                   | 多线程程序                         |
| **目标**       | 保证单线程结果正确性，允许优化               | 定义多线程操作间的可见性与顺序约束 |
| **重排序限制** | 允许无数据依赖的重排序                       | 通过规则限制重排序                 |
| **内存可见性** | 不涉及多线程内存可见性                       | 确保跨线程操作的可见性             |
| **关系**       | happens-before在单线程中是as-if-serial的特例 | 扩展了as-if-serial到多线程环境     |

------

总之**as-if-serial**使得开发者无需担心单线程内的重排序问题，只需关注代码逻辑正确性，编译器和处理器可以自由优化，只要不影响单线程结果。而**happens-before**使得开发者可以通过规则（如锁、volatile、线程启动等）控制多线程的执行顺序和可见性，以及避免因指令重排序或缓存不一致导致的多线程Bug（如可见性问题、有序性问题）。
