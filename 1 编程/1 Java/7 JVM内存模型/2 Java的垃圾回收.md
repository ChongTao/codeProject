# 1 如何确定垃圾

在JVM中，确定垃圾的过程主要依赖于垃圾收集器（Garbage Collector）的两种算法：引用计数算法（Reference Counting）和可达性分析算法（Reachability Analysis）。

1. **引用计数算法**：这种算法的基本思路是为每个对象添加一个引用计数器。每当有一个地方引用这个对象，计数器就加1；每当一个引用失效（例如，赋值为null或超出作用域），计数器就减1。如果计数器为0，那么这个对象就是不可能再被使用的，因此可以将其标记为垃圾对象。然而，这种算法存在一个问题，即无法解决对象间的循环引用问题。
2. **可达性分析算法**：为了解决引用计数算法的循环引用问题，JVM引入了可达性分析算法。这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起点，从这些GC Roots开始向下搜索。如果一个对象到GC Roots没有任何引用链相连（即不可达），那么这个对象就被标记为垃圾对象。在Java中，可以作为GC Roots的对象包括虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象，以及本地方法栈中JNI（即Java Native Interface）引用的对象。

需要注意的是，垃圾回收的过程并不一定会立即执行垃圾对象的回收。具体的回收时机和方式取决于垃圾收集器的策略和配置。此外，由于垃圾回收可能会对系统性能产生影响（如暂停时间、吞吐量等），因此在进行JVM调优时需要综合考虑各种因素，以制定出合适的垃圾回收策略。

# 2 JVM垃圾回收算法

垃圾回收算法是JVM（Java虚拟机）中用于自动管理内存的重要机制。

## 2.1 标记-清除算法

标记清除（Mark-Sweep）算法是垃圾回收中的一种常见算法，用于自动管理内存中的不再使用的对象。

标记清除算法分为两个阶段：标记阶段和清除阶段。

1. **标记阶段**：从根节点（通常是栈中的引用或静态变量等）开始，遍历所有可达对象，并将它们标记为“存活”。标记操作可以通过在对象的内存块中设置特定标记位或使用其他数据结构（如标记栈）来实现。
2. **清除阶段**：遍历整个堆内存，查找未被标记的对象（即不可达对象或垃圾对象），并释放它们的内存空间。清除操作可以简单地回收整个对象的内存块，或者将对象的内存块标记为空闲以供后续分配使用。

其优缺点如下：

- **灵活性**：标记清除算法可以处理任意类型的数据结构，因为它不依赖于对象的特定布局或大小。
- **效率**：与复制算法相比，标记清除算法不需要将内存划分为两个区域，因此内存使用效率更高。
- **适用性**：标记清除算法适用于存活对象较多的场景，因为它不需要移动存活对象，只需标记和清除垃圾对象。
- **效率问题**：标记和清除过程都需要遍历整个堆内存，这可能会导致较大的性能开销。特别是在堆内存较大或存活对象较多的情况下，GC暂停时间可能会较长。
- **内存碎片**：标记清除算法在回收对象后，可能会留下不连续的内存碎片。这些碎片可能会导致后续的内存分配变得困难，因为系统可能需要寻找足够大的连续内存块来满足分配需求。内存碎片问题可能会降低内存使用效率和程序的性能。
- **需要额外的标记和清除操作**：标记清除算法需要额外的标记和清除操作，这增加了垃圾回收的复杂性和开销。

标记清除算法通常与其他垃圾回收算法结合使用，以改善其缺点。例如，在Java的HotSpot虚拟机中，老年代（Old Generation）中的垃圾回收就采用了标记清除算法与标记整理（Mark-Compact）算法的结合。通过标记整理算法，可以将存活对象移动到一起，从而减少内存碎片的产生。

## 2.2 复制算法

复制算法是垃圾回收中的一种算法，其原理是将内存划分为两个等大的区域，每次只使用其中一个区域进行对象分配。当这个区域用完后，垃圾收集器会暂停程序的执行（Stop-The-World事件），将存活的对象复制到另一个空闲的区域中，然后清除整个已使用的区域，使得两个区域的角色互换。复制算法的优点和缺点如下：

- **简单高效**：复制算法实现起来较为简单，因为它只需要复制存活的对象到另一个区域，不需要进行标记和清除操作。

- **避免内存碎片**：由于每次都是在新的区域中分配对象，因此复制算法可以避免内存碎片的产生。

- **空间连续性**：复制算法可以保证存活对象的内存空间连续性，这对于某些需要连续内存空间的应用场景（如数组操作）是有利的。

- **内存使用效率低**：复制算法需要划分出两块等大的内存区域，而每次只使用其中一块，因此内存使用效率只有50%。这意味着系统需要更多的内存来支持相同的对象数量。

- **不适用于存活对象多的场景**：如果系统中存活对象较多，那么复制算法需要复制的对象也会很多，这会导致复制操作的时间开销增大，降低系统的整体性能。

- **GC暂停时间长**：由于复制算法需要在复制对象时暂停程序执行，因此GC暂停时间可能会较长，对系统的实时性要求较高的应用可能会受到影响。

复制算法通常适用于新生代中的垃圾回收，因为新生代中对象存活率较低，复制操作的时间开销相对较小。在Java的HotSpot虚拟机中，年轻代（Young Generation）中的Eden区就采用了复制算法进行垃圾回收。

## 2.3 标记-整理算法

标记清除（Mark-Sweep）算法是垃圾回收中的一种常见算法，用于自动管理内存中的不再使用的对象。标记清除算法分为两个阶段：标记阶段和清除阶段。

1. **标记阶段**：从根节点（通常是栈中的引用或静态变量等）开始，遍历所有可达对象，并将它们标记为“存活”。标记操作可以通过在对象的内存块中设置特定标记位或使用其他数据结构（如标记栈）来实现。
2. **清除阶段**：遍历整个堆内存，查找未被标记的对象（即不可达对象或垃圾对象），并释放它们的内存空间。清除操作可以简单地回收整个对象的内存块，或者将对象的内存块标记为空闲以供后续分配使用。其优缺点如下：

- **灵活性**：标记清除算法可以处理任意类型的数据结构，因为它不依赖于对象的特定布局或大小。

- **效率**：与复制算法相比，标记清除算法不需要将内存划分为两个区域，因此内存使用效率更高。

- **适用性**：标记清除算法适用于存活对象较多的场景，因为它不需要移动存活对象，只需标记和清除垃圾对象。

- **效率问题**：标记和清除过程都需要遍历整个堆内存，这可能会导致较大的性能开销。特别是在堆内存较大或存活对象较多的情况下，GC暂停时间可能会较长。

- **内存碎片**：标记清除算法在回收对象后，可能会留下不连续的内存碎片。这些碎片可能会导致后续的内存分配变得困难，因为系统可能需要寻找足够大的连续内存块来满足分配需求。内存碎片问题可能会降低内存使用效率和程序的性能。

- **需要额外的标记和清除操作**：标记清除算法需要额外的标记和清除操作，这增加了垃圾回收的复杂性和开销。

标记清除算法通常与其他垃圾回收算法结合使用，以改善其缺点。例如，在Java的HotSpot虚拟机中，老年代（Old Generation）中的垃圾回收就采用了标记清除算法与标记整理（Mark-Compact）算法的结合。通过标记整理算法，可以将存活对象移动到一起，从而减少内存碎片的产生。

## 2.4 分代收集算法

分代回收（Generational Collection）算法是Java虚拟机中常用的一种垃圾回收算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域，然后根据各个区域中对象的特点采用最适合的垃圾回收算法。

分代回收算法将堆内存划分为新生代（Young Generation）和老年代（Old Generation）两个区域。新生代中的对象大多数是朝生夕灭的，即存活时间较短；而老年代中的对象则存活时间较长。基于这种特点，分代回收算法对新生代和老年代采用不同的垃圾回收策略。

1. **新生代（Young Generation）**：

   新生代中的对象存活率较低，因此采用复制算法进行垃圾回收。新生代又被进一步划分为Eden区、Survivor From区和Survivor To区。当Eden区满时，会触发Minor GC，将存活的对象复制到Survivor区（From或To），并清空Eden区。当Survivor区不足以容纳更多对象时，会再次触发Minor GC，并将存活的对象复制到另一个Survivor区，同时将这些对象年龄加1。当对象年龄达到一定程度（如15岁）时，会晋升到老年代。

2. **老年代（Old Generation）**：

   老年代中的对象存活率较高，因此采用标记清除算法或标记整理算法进行垃圾回收。当老年代空间不足时，会触发Major GC（也称为Full GC），对老年代进行垃圾回收。Major GC通常会暂停程序的执行，因此对系统性能影响较大。

该算法的优缺点如下：

- **提高垃圾回收效率**：分代回收算法根据对象存活周期的不同特点，采用不同的垃圾回收策略，从而提高了垃圾回收的效率。

- **降低GC暂停时间**：通过划分新生代和老年代，并在新生代中采用复制算法，可以减少GC暂停时间，提高系统的实时性。

- **减少内存碎片**：在老年代中采用标记整理算法，可以解决内存碎片问题，提高内存使用效率。

- **内存划分固定**：分代回收算法将内存划分为固定大小的新生代和老年代，这可能会导致内存使用的浪费或不足。如果新生代大小设置不当，可能会导致频繁的Minor GC或Major GC。

- **需要调整GC参数**：分代回收算法需要根据应用程序的特点和性能需求来调整GC参数，如新生代和老年代的大小、晋升年龄等。这需要一定的经验和专业知识。

- **不适用于所有场景**：分代回收算法适用于大多数Java应用程序，但在某些特殊场景下（如大量长生命周期对象的存在），可能不适合使用分代回收算法。

# 3 垃圾回收器

Java中的垃圾回收器（Garbage Collector，简称GC）有多种类型，它们可以根据不同的场景和需求进行选择和使用。以下是一些常见的Java垃圾回收器：

## 3.1 Serial收集器

这是Java虚拟机中最基本、发展最稳定的收集器。它采用复制算法，适用于单线程环境，具有简单、高效的特点。但它的缺点是会导致应用程序暂停，即“Stop The World”。

## 3.2 Parallel Scavenger收集器

这是一个并行收集器，适用于多核处理器环境。它采用复制算法，并行收集可以充分利用多核处理器的优势，提高垃圾回收效率。Parallel Scavenger收集器关注吞吐量，适用于后台运算而不需要太多交互的任务。

## 3.2 Parallel Old收集器

这是Parallel Scavenger收集器的老年代版本，用于处理老年代中的垃圾回收。它采用标记整理算法，同样适用于多核处理器环境。

## 3.3 CMS（Concurrent Mark Sweep）收集器

CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它采用标记清除算法，可以并发地进行垃圾回收，减少应用程序的暂停时间。但CMS收集器可能会产生内存碎片，并且在处理大量对象时可能会导致性能下降。

CMS（Concurrent Mark Sweep）垃圾回收器是Java虚拟机中的一种垃圾回收器，它采用了标记清除算法来实现垃圾回收。CMS垃圾回收器基于标记清除算法进行工作，整个过程分为以下几个阶段：

1. **初始标记（Initial Mark）**：此阶段会暂停所有的应用线程（Stop-The-World），记录能被GC Root直接引用的对象。这个阶段的速度很快，因为只标记GC Root直接关联的对象。
2. **并发标记（Concurrent Mark）**：此阶段从GC Roots的直接引用对象开始依次扫描，用户线程和GC线程同时执行，不会产生STW。在这个过程中，标记过的对象可能会因为用户线程的执行而再次变成垃圾。
3. **重新标记（Remark）**：此阶段需要暂停所有的应用线程，对并发标记阶段产生的浮动垃圾进行修正。
4. **并发清除（Concurrent Sweep）**：此阶段GC线程和用户线程同时进行，开始正式清除未被标记的垃圾。

其优缺点如下：

- **并发收集**：CMS垃圾回收器在垃圾回收过程中不需要停止应用程序的运行，因此可以减少应用程序的停顿时间，提高应用程序的响应速度。

- **高吞吐量**：在适当的情况下，CMS垃圾回收器能够提供很高的吞吐量，使得应用程序的吞吐量得到提高。

- **内存碎片问题**：由于使用标记清除算法，会产生内存碎片，分配对象时内存不足，造成并发失败触发Full GC，这时老年代并发垃圾回收器会退化到SerialOld串行垃圾回收器使用标记整理算法并进行整理，碎片减少后才能继续工作，但这会导致垃圾回收的整体时间变长。

- **需要预留空间**：CMS垃圾收集器在回收垃圾的同时需要处理用户线程，因此需要在这个过程中保证有充足的内存空间供用户使用。碎片内存会加剧空间的问题，导致触发Full GC而使卡顿时间可能更长。

- **使用更多的CPU资源**：在应用运行的同时进行堆扫描，会占用更多的CPU资源。

## 3.4 G1（Garbage-First）收集器

G1收集器是一款面向服务端应用的垃圾回收器。它采用标记整理算法，并引入了分区（Region）的概念。G1收集器可以预测各个Region的垃圾收集成本，并优先回收价值最大的Region，以提高垃圾回收效率。同时，G1收集器还可以并发地进行垃圾回收，减少应用程序的暂停时间。G1（Garbage-First）垃圾收集器是JDK 7及之后版本中引入的一款垃圾收集器。

G1垃圾收集器采用了分代的垃圾回收策略，它将堆内存划分为多个独立的区域（Region），这些区域可以是年轻代（Eden区和Survivor区）或老年代。G1通过每次只处理部分Region的垃圾回收任务，而不是全堆进行垃圾回收，这种增量的垃圾处理方式保证了每次GC不会造成长时间的停顿。

在回收过程中，G1会跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），并在后台维护一个优先列表。根据允许的收集时间，G1会优先回收价值最大的Region，从而确保在有限的时间内获取尽可能高的收集效率。

此外，G1还采用了并行与并发的垃圾回收方式。在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。同时，G1也具备与应用程序交替执行的能力，部分工作可以和应用程序同时执行，从而减少了对整个回收阶段的阻塞。

其优缺点如下：

- **低停顿时间**：G1垃圾收集器通过每次只处理部分Region的垃圾回收任务，以及优先回收价值最大的Region，从而减少了每次GC的停顿时间。

- **高吞吐量**：G1通过并行与并发的垃圾回收方式，有效利用了多核计算能力，提高了整体的吞吐量。

- **可预测的停顿时间模型**：G1提供了可预测的停顿时间模型，可以让使用者明确指定在一个时间片段内，消耗在垃圾收集上的时间不得超过指定值。

- **内存占用和额外执行负载**：相较于其他垃圾收集器，G1在垃圾收集过程中会产生更高的内存占用和额外的执行负载。

- **对硬件资源敏感**：G1在某些情况下可能对硬件资源较为敏感，例如当JVM的GC线程处理速度不理想时，系统可能会调用应用程序线程帮助加速垃圾回收工作，这可能会对应用程序的性能产生影响。

G1垃圾收集器适用于具有大内存、多核心处理器的机器，特别是那些需要低GC延迟且堆内存空间较大的程序。在堆空间大小超过6GB时，G1的性能表现优异。此外，当对象分配频率或年代提升频率较高，以及GC停顿时间较长（例如0.5-1秒）的情况下，也可以考虑使用G1替换其他垃圾收集器。

总的来说，G1垃圾收集器是一种适用于服务端应用、具有大内存和多核处理器的垃圾收集器，它通过分代、增量、并行与并发的垃圾回收策略，以及可预测的停顿时间模型，为应用程序提供了更好的性能和稳定性。然而，在实际使用中，还需要根据具体的应用场景、性能需求和硬件配置进行综合考虑和评估。



# 4 JMM的内存模型

JDK 1.8的内存模型如下：

![image-20250323155505294](C:\Users\崇涛\AppData\Roaming\Typora\typora-user-images\image-20250323155505294.png)

## 4.1 堆

在Java中，堆内存主要分为两个区域：新生代（Young Generation）和老年代（Old Generation）。这是为了更好地管理堆内存中的对象，包括内存的分配和回收。

1. **新生代（Young Generation）**：
   - 新生代又可以进一步划分为三个区域：Eden区、From Survivor区和To Survivor区。其中，Eden区用于新创建的对象。当Eden区满时，会触发一次Minor GC（垃圾收集），此时，Eden区还存活的对象会被移动到Survivor区（From或To，具体哪一个取决于当前的GC阶段）。
   - From Survivor区和To Survivor区是两个大小为Eden区一半的内存区域，它们用于在GC过程中存放存活的对象。在每次GC后，From Survivor区和To Survivor区的角色会互换。
2. **老年代（Old Generation）**：
   - 老年代存放的都是生命周期较长的对象。当新生代中的对象经过多次GC仍然存活时，它们会被移动到老年代。老年代的GC称为Major GC或Full GC，因为涉及的对象较多，所以它的执行成本相对较高。

在Java的JVM中，堆内存中的新生代（Young Generation）和老年代（Old Generation）的比例可以通过参数`-XX:NewRatio`来指定。默认情况下，这个比例是1:2，也就是说，新生代占整个堆内存的1/3，而老年代占2/3。

具体来说，新生代被细分为Eden区和两个Survivor区（From Survivor和To Survivor），它们的默认比例是8:1:1。这意味着Eden区占新生代空间的8/10，而每个Survivor区（From和To）各占1/10。因此，新生代实际可用的内存空间为9/10（即90%）。

请注意，这些默认值可以通过JVM启动参数进行调整，以满足特定应用程序的需求。例如，通过增加新生代的大小，可以减少老年代的垃圾收集频率，但可能会增加新生代的垃圾收集频率。相反，减少新生代的大小可能会减少新生代的垃圾收集频率，但可能会增加老年代的垃圾收集频率。因此，需要根据应用程序的特性来选择合适的比例。

在Java 8及以后的版本中，永久代（PermGen）被元空间（Metaspace）所取代。元空间用于存放类的元数据，它位于本地内存中，而不是JVM的堆内存中。因此，它不再是堆内存的一部分。
