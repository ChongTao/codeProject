# 1 Redis 为什么那么快

Redis之所以快，主要有以下原因：

- **数据结构与内部编码**：Redis支持多种数据结构，如string、hash、list、set、zset等，每种数据结构都有对应的内部编码。这种设计可以根据存储的键值对的个数和大小来决定使用哪种内部编码，从而改进内部编码，提高性能。

- **单线程架构**：Redis采用单线程架构，避免了多线程中的线程切换和竞态产生的消耗。同时，Redis的所有数据都存储在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。

- **多路复用IO**：Redis采用多路复用IO技术，可以让单个线程高效的处理多个连接请求，减少网络IO的时间消耗。

- **C语言实现**：Redis使用C语言实现，C语言更接近操作系统，执行速度相对更快。

- **哈希冲突解决**：Redis使用哈希冲突链解决哈希冲突，当冲突链过长时进行渐进式rehash，增加现有桶的数量，保证查询速度。

# 2 Redis 为什么用单线程?

Redis采用单线程模型的主要原因有以下几点：

1. **简单性和高效性**：单线程模型减少了多线程模型中可能存在的复杂性，如锁和同步的开销。这使得Redis能够更专注于提供高性能的键值存储服务。
2. **避免线程切换开销**：多线程模型在并发量较高时，线程切换的开销可能会成为性能瓶颈。而Redis的单线程模型则避免了这一问题，从而提高了整体性能。
3. **内存操作优势**：Redis主要操作的是内存数据，而内存访问速度非常快。在这种情况下，单线程模型能够充分发挥CPU的计算能力，避免多线程模型中的线程竞争和切换开销。
4. **可预测性**：单线程模型使得Redis的性能更可预测，避免了多线程模型中可能出现的性能波动。这对于需要稳定性能的应用来说是非常重要的。
5. **减少复杂性**：使用单线程模型可以减少Redis的复杂性，降低开发和维护的难度。同时，这也使得Redis更容易被理解和使用。

# redis集群三种模式

Redis集群的三种模式分别是：

1. **主从复制集群**：在这种模式下，Redis集群由一个或多个主节点和多个从节点组成。主节点用于处理读写操作，而从节点则用于备份数据。当主节点出现故障时，从节点会自动接管主节点的操作，确保服务的连续性。然而，这种模式的效率和性能可能较低，因为增加从节点可以提高可用性，但并不能提高性能。
2. **哨兵模式（Sentinel）**：这是Redis官方提供的高可用性解决方案。哨兵模式通过监控Redis服务器的状态，可以自动检测主节点的故障，并在主节点宕机后自动将从节点切换为主节点，从而确保Redis系统的高可用性。哨兵模式还允许动态添加或删除节点，管理Redis的主从复制，并执行自动故障转移。
3. **集群模式（Cluster）**：这是目前最受欢迎的Redis集群方案。集群模式采用无中心架构，数据被分片存储在多个节点上，每个节点负责部分数据的读写操作。客户端可以直接访问任意节点，集群内部通过Gossip协议进行节点之间的状态同步和故障检测。集群模式对于数据的一致性和可靠性有很好的保证，适用于大规模高可用的分布式系统。



# Redis 缓存有哪些淘汰策略

Redis缓存淘汰策略有以下几种：

1. **LRU（Least Recently Used）**：这是Redis的默认淘汰策略。当内存不足以容纳新写入数据时，Redis会根据键的最近使用时间来淘汰数据，即最近最少使用的数据会被优先淘汰。
2. **LFU（Least Frequently Used）**：Redis会根据键的使用频率来淘汰数据，即使用频率最低的数据会被优先淘汰。
3. **Random**：Redis会随机选择一些数据进行淘汰。
4. **TTL（Time To Live）**：Redis会根据键的过期时间来淘汰数据，即过期时间最早的数据会被优先淘汰。
5. **Maxmemory-policy**：这是Redis的最大内存策略，当达到最大内存限制时，Redis会根据配置的策略来淘汰数据。常见的策略有`noeviction`（不淘汰数据，直接返回错误）、`allkeys-lru`（使用LRU策略淘汰所有键中的数据）等。

此外，对于设置了过期时间的数据集，Redis还提供了以下淘汰策略：

1. **volatile-lru**：从已设置过期时间的数据集挑选最近最少使用的数据淘汰。
2. **volatile-lfu**：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。
3. **volatile-ttl**：从已设置过期时间的数据集挑选将要过期的数据淘汰。
4. **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰。

# Redis的过期键的删除策略

Redis的过期键删除策略主要有三种，分别是**定时删除、惰性删除和定期删除**。

1. **定时删除**：在设置键的过期时间的同时，创建一个定时器，让定时器在键过期时立即删除键。这种策略对内存友好，可以尽快释放过期键所占用的内存，但对CPU不友好，因为当过期键比较多时，删除操作会占用大量的CPU资源，对服务器的响应时间和吞吐量造成影响。
2. **惰性删除**：只有当键被访问时，才会判断键是否过期，如果过期则删除该键。这种策略对CPU友好，因为删除操作只在键被访问时进行，避免了不必要的CPU资源浪费，但对内存不友好，因为过期键在被访问前不会被删除，仍然会占据内存空间，如果大量过期键很少被访问，会造成内存空间的浪费。
3. **定期删除**：每隔一段时间就检查一次键的过期情况，如果发现过期键则删除。这种策略是前两种策略的折中方案，可以通过合理设置删除操作的执行时间和执行频率来平衡CPU和内存的负载。Redis实际使用的是惰性删除和定期删除两种策略的结合。

需要注意的是，Redis的过期键删除策略的选择应该根据具体的应用场景和需求来决定，不同的策略可能会对Redis的性能和数据一致性产生不同的影响。同时，还需要注意Redis的内存淘汰机制，当内存不足以容纳新写入数据时，Redis会根据配置的内存淘汰策略来淘汰部分数据。

# LRU和LFU 区别和原理

LRU（Least Recently Used）和LFU（Least Frequently Used）是两种常见的缓存替换算法，它们在处理缓存替换时的原理和使用场景有所不同。

LRU（Least Recently Used）算法是基于最近使用时间的缓存替换算法。它的基本思想是：当缓存空间不足时，优先淘汰最长时间未被访问的数据。LRU算法维护一个访问顺序链表（或双向链表），每次访问一个数据时，将其移动到链表的头部。当需要淘汰数据时，选择链表尾部的数据进行删除。这种算法适用于访问模式具有时间局部性的场景，即最近被访问过的数据在未来被访问的可能性也更高。

LFU（Least Frequently Used）算法则是基于访问频率的缓存替换算法。它的核心思想是：当缓存空间不足时，优先淘汰访问频率最低的数据。LFU算法维护一个频率计数器，用于记录每个数据被访问的次数。每次访问一个数据时，将对应数据的访问次数加1。当需要淘汰数据时，选择访问次数最低的数据进行删除。这种算法适用于访问模式具有频率局部性的场景，即访问频率较高的数据在未来被访问的可能性也更高。

在实际应用中，可以根据具体的场景选择合适的缓存替换算法。LRU算法实现简单，适用于大多数情况，而LFU算法在某些特定场景下可能具有更好的性能。有些系统还会结合两种算法，根据实际情况动态选择使用哪种算法。

# 1 redis数据类型

## 1.1 字符串

这是Redis最基本的类型，一个key对应一个value。字符串类型可以是二进制安全的，意味着它可以包含任何数据，例如jpg图片或者序列化的对象。字符串类型的值最大能存储512MB。

1. Hash（哈希）：Redis的哈希是一个键值对集合，是一个string类型的field和value的映射表，特别适合用于存储对象。每个hash可以存储2^32 - 1个键值对。
2. List（列表）：Redis的列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到头部（左边）或者尾部（右边）。列表最多可以存储2^32 - 1个元素。
3. Set（集合）：Redis的集合是无序的，意味着你不能从集合中获取元素的顺序。集合中的元素是唯一的，意味着集合中不会出现重复的元素。Redis的集合支持多个集合求交集、并集、差集，适合实现共同关注之类的需求。一个集合最多可以存储2^32 - 1个元素。
4. Zset（有序集合）：有序集合和集合类似，也是字符串类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)可以重复。



Redis支持五种数据类型，每种数据类型都有其特定的常见方法。以下是这五种数据类型及其常见方法的简要概述：

1. **String（字符串）**

   - **应用场景**：常用于统计网站访问数量、当前在线人数等。

   - 常用方法

     ：

     - `INCR`：将键的值原子性递增1。
     - `DECR`：将键的值原子性递减1。
     - `GETSET`：先获取键的值，然后设置新值。

2. **Hash（哈希）**

   - **应用场景**：存储、读取、修改用户属性（如name、age、pwd等）。

   - 常用方法

     ：

     - `HSET`：设置哈希表中的一个字段的值。
     - `HGET`：获取哈希表中一个字段的值。
     - `HDEL`：删除哈希表中的一个或多个字段。

3. **List（列表）**

   - **应用场景**：最新消息排行榜、消息队列等。

   - 常用方法

     ：

     - `LPUSH`：将一个或多个值插入到列表头部。
     - `RPUSH`：将一个或多个值插入到列表尾部。
     - `LPOP`：移除并获取列表的第一个元素。
     - `RPOP`：移除并获取列表的最后一个元素。

4. **Set（集合）**

   - **应用场景**：用于存储无序的字符串集合。

   - 常用方法

     ：

     - `SADD`：向集合添加一个或多个成员。
     - `SREM`：从集合中移除一个或多个成员。
     - `SISMEMBER`：检查一个成员是否存在于集合中。

5. **Zset（有序集合）**

   - **应用场景**：用于一个大型在线游戏的积分排行榜等，需要按照分数排序的场景。

   - 常用方法

     ：

     - `ZADD`：向有序集合添加一个或多个成员，或者更新已存在成员的分数。
     - `ZRANGE`：获取有序集合中指定范围的成员。
     - `ZREM`：从有序集合中移除一个或多个成员。

请注意，Redis的所有操作都是原子性的，并采用单线程处理所有业务。命令是一个一个执行的，因此无需考虑并发带来的数据影响。此外，对于数值增减操作，如果原始数据不能转成数值或超出了Redis的数值上限范围，将报错。

# 每种数据类型的适用场景

Redis的五种数据类型及其适用场景如下：

1. **String（字符串）**：
   - **常规key-value缓存应用**：字符串是最常用的数据类型，可以用作普通的key/value存储。
   - **计数功能**：例如，用于微博数、粉丝数等的计数。
   - **数据结构序列化**：可以将其他数据结构如JSON等序列化为字符串存储。
2. **Hash（哈希）**：
   - **存储对象信息**：哈希对象的键是一个字符串类型，值是一个键值对集合，因此非常适合存储对象的信息。
   - **部分变更的数据**：如用户信息等，只更新变更的部分，而不是整个对象。
3. **List（列表）**：
   - **消息队列**：列表类型常用来做异步队列使用。
   - **排行榜功能**：可以轻松地实现最新消息排行等功能。
   - **栈和队列**：Redis的列表是一个双向链表，可以支持push和pop操作，因此可以用作栈或队列。

4. **Set（集合）**：
   - **唯一性检查**：例如，用于检查用户是否已经点赞或关注。
   - **交集、并集和差集操作**：Redis为集合提供了求交集、并集、差集等操作，可以用于实现如共同关注、共同喜好等功能。
5. **Zset（有序集合）**：
   - **排行榜和计数器**：有序集合适合用来存储排行榜、热门排行和计数器等信息。
   - **有序操作**：由于集合是有序的，因此可以进行范围查询和有序的成员操作。

请注意，这些适用场景只是一些常见的用例，实际上Redis的数据类型非常灵活，可以根据具体的应用需求进行多种组合和使用。



# 跳表怎么实现的

跳表（Skip List）是一种可以实现快速查找、插入和删除操作的数据结构，它是基于链表的，但在原有的链表基础上增加了多级索引，通过索引来实现快速查找。跳表的操作效率可以达到 O(logN)，且实现相对简单。

跳表的实现主要包括以下几个部分：

1. **节点结构**：跳表的节点包含两个指针，一个指针指向同层链表的后一节点，另一个指针指向下层链表的同元素节点。这样的结构使得跳表可以在多个层次上进行查找和遍历。
2. **索引层**：跳表由多个索引层组成，每个索引层都是一个有序链表。最高层索引包含的元素最少，但每个元素的间隔最大；而最底层索引包含的元素最多，但每个元素的间隔最小。这样的结构可以在查找时快速跳过大量元素，从而提高查找效率。
3. **随机化**：跳表中的元素在哪一层出现是随机决定的，但是只要元素出现在了第 k 层，那么 k 层以下的链表也会出现这个元素。这样可以保证跳表的查找效率。
4. **查找操作**：查找时，首先从最高层索引开始查找，找到小于等于目标值的最大元素，然后逐层下降到下一层索引继续查找，直到降到最底层为止。在最底层，按照链表顺序查找，找到第一个大于等于目标值的元素，即为所查找的元素。
5. **插入和删除操作**：插入和删除操作与查找操作类似，也是从最高层索引开始，逐层下降到最底层进行插入或删除。

# 压缩列表怎么实现的

压缩列表（ziplist）是 Redis 中用于实现列表键和哈希键的底层数据结构之一，特别适用于包含少量列表项且每个列表项是小整数值或短字符串的场景。压缩列表是为了节约内存而开发的，由一系列特殊编码的连续内存块组成的顺序型数据结构。

压缩列表的实现主要包括以下几个部分：

1. **节点构成**：每个压缩列表节点可以保存一个字节数组或一个整数值。字节数组可以是以下三种长度之一：一字节、两字节或五字节长。值的最高位为 00、01 或 10 的表示字节数组编码，这种编码表示节点的 content 属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录。
2. **内存分配**：压缩列表的内存分配是连续的，并且采用预分配和惰性空间释放两种策略来平衡内存使用和碎片。预分配策略是在添加新节点时，如果空间不足，会按照一定规则分配更多的内存空间。而惰性空间释放策略则是在删除节点后，不会立即回收内存，而是等待将来需要添加新节点时再利用这些空间。
3. **连锁更新**：在压缩列表中，节点的删除和插入操作可能会引发连锁更新操作。例如，当删除一个节点后，可能需要更新多个节点的 prev_entry_length 字段。但这种连锁更新的几率并不高，因为 Redis 在设计压缩列表时已经尽量减少了这种情况的发生。
4. **查找操作**：由于压缩列表是顺序型数据结构，查找操作需要从表头开始逐个遍历节点，直到找到目标节点或遍历完整个列表。因此，在包含大量节点的压缩列表中，查找操作的性能可能会较低。
