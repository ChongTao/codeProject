# 1 面向对象和面向过程的区别

面向对象和面向过程是两种不同的编程范式，它们在设计思路、实现方式和程序设计风格等方面有明显的区别。

## 1.1 设计思路

- 面向过程是一种以函数为基本单位的编程方法，它的核心是算法。在这种范式中，程序员会将一个复杂的问题分解为多个步骤，每个步骤对应一个函数，通过调用这些函数实现整个问题的解决。
- 面向对象则是以对象为核心，通过封装、继承和多态等特性实现代码复用和扩展。在这种范式中，程序员会将构成问题的事物分解成各个对象，每个对象都有自己的属性和行为，通过对象之间的交互来解决问题。
  
## 1.2 实现方式

- 面向过程采用函数调用的方式实现功能。在这种方式下，程序按照函数调用的顺序依次执行，每个函数完成特定的任务。
- 面向对象采用对象的方式实现功能。在这种方式下，程序员会创建多个对象，每个对象都有自己的属性和方法，通过对象之间的交互来实现程序的功能。

## 1.3 程序设计风格

- 面向过程程序设计以函数为基本单位，结构化，适用于小型程序开发。在这种风格下，程序按照一系列函数的调用顺序来执行，每个函数都负责完成特定的任务。
- 面向对象程序设计以类和对象为基本单位，层次化，适用于大型程序开发。在这种风格下，程序由多个对象组成，每个对象都有自己的属性和方法，通过对象之间的交互来实现程序的功能。

此外，面向对象和面向过程在性能、可用性和扩展性等方面也存在差异。一般来说，面向过程在性能上较高，适用于对性能要求较高的场景，如单片机、嵌入式开发等。而面向对象在可用性、扩展性和可维护性方面更具优势，可以设计出低耦合、高内聚的系统，更易于维护和扩展。

# 2 面向对象三大特征

面向对象的三大特征包括封装、继承和多态。

1. 封装：封装是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作和访问。封装把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。封装的目的在于隐藏实现细节，使得代码模块化，同时保护某些数据不被程序中的无关部分错误调用。
2. 继承：继承是面向对象编程（OOP）语言的一个主要功能。它允许使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。子类可以继承父类的属性和行为，这意味着父对象拥有的属性和行为，其子对象也拥有。这种继承关系类似于大自然中的物种遗传。
3. 多态：多态性是指允许将子类类型的指针赋值给父类类型的指针，使得父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。多态性允许不同类的对象对同一消息作出响应，实现接口的重用。多态性包括参数化多态性和包含多态性。

# 3 重载和重写区别

重载（Overloading）和重写（Overriding）是面向对象编程中两个重要的概念，它们在Java等编程语言中得到了广泛应用。以下是它们之间的主要区别：

## 3.1 重载

在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表（参数类型、参数个数或参数顺序）不同即可。重载的目的是让类以统一的方式处理不同类型的数据。

## 3.2 重写

子类可以重新定义父类中的方法，要求方法名、参数列表必须相同，但返回类型可以不同（子类方法的返回类型可以是父类方法返回类型的子类型）。重写的目的是子类可以对父类的行为进行修改或扩展。

## 3.3 区别

1. 重载发生在一个类中，属于编译时的多态性。在调用方法时，通过传递不同的参数个数和类型来决定具体使用哪个方法。重写发生在子类与父类之间，属于运行时的多态性。在运行时，根据对象的实际类型来决定调用哪个方法。
2. 重载要求同名方法的参数列表不同，但返回类型可以相同也可以不同。无法以返回类型来作为重载函数的区分标准。而重写要求方法名、参数列表相同，但返回类型可以是父类方法返回类型的子类型。此外，重写方法的访问权限不能比父类中被重写的方法的访问权限更严格。
3. 重载方法可以有不同的异常列表。重写方法不能抛出新的或更广泛的检查型异常，只能抛出与父类方法相同或更少的异常。

# 4 接口和抽象类有什么共同点和区别

## 4.1 接口和抽象类的相同点

1. **都不能被实例化**：无论是接口还是抽象类，都不能直接创建对象。对于接口，它定义的是一组行为规范，不能直接实例化；对于抽象类，它包含抽象方法，不能直接实例化。
2. **都可以包含抽象方法**：接口和抽象类都可以包含抽象方法，这些抽象方法用于描述类应该具备的功能，但不提供具体的实现。
3. **都可以被子类/实现类继承/实现**：抽象类可以被普通类继承，而接口可以被普通类实现。子类/实现类必须实现/重写所有的抽象方法。

## 4.2 接口和抽象类的差异

1. 抽象类是一种特殊的类，它不能被实例化，但可以包含普通成员变量和非抽象方法。接口则是一种完全抽象的类型，它只能包含抽象方法和常量。
2. 一个类只能继承一个直接父类，但可以实现多个接口。这是因为接口中只能包含抽象方法，没有具体的实现，因此实现多个接口并不会产生冲突。而抽象类则可以包含具体的实现，因此一个类只能继承一个抽象类，避免多重继承带来的复杂性。
3. 抽象类中可以包含非抽象方法，这些非抽象方法可以被子类继承并直接使用，这可以避免在子类中重复书写相同的代码，提高了代码的复用性。而接口中只能有抽象方法，不能包含非抽象方法。
4. 抽象类可以有构造方法，用于初始化抽象类中的普通成员变量。而接口不能有构造方法，因为接口不能被实例化。
5. 抽象类可以继承其他抽象类或具体的类，而接口只能继承其他接口，不能继承具体的类。

# 5 介绍private、protected、public

在Java编程语言中，`private`、`protected`和`public`是访问修饰符，用于设置类、变量、方法和构造函数的访问权限。它们决定了哪些其他类可以访问这些成员。以下是这三个访问修饰符之间的主要区别：

1. **public（公共的）**：
   - 当一个类的成员被声明为`public`时，它意味着该成员对所有的类都是可见的，并且可以在任何地方被访问。
   - `public`是访问权限最宽松的关键字，它允许任何类访问该成员，无论它们是否在同一个包内。
2. **private（私有的）**：
   - 当一个类的成员被声明为`private`时，它只能被声明它的类内部访问。
   - `private`是访问权限最严格的关键字，它防止任何其他类访问该成员。
   - `private`成员通常用于隐藏类的内部实现细节，确保类的封装性。
3. **protected（受保护的）**：
   - `protected`关键字允许成员被其所在类的子类以及同一个包内的其他类访问。
   - 如果两个类不在同一个包内，但是一个是另一个的子类，那么子类可以访问父类的`protected`成员。
   - `protected`提供了比`private`更宽松的访问权限，但比`public`更严格的访问权限。

# 6 构造方法有哪些特点？是否可被 override?

Java中的构造方法（也称为构造函数）具有以下特点：

1. **名称与类名相同**：构造方法的名称必须与类的名称完全相同，包括大小写。
2. **没有返回类型**：构造方法不能有返回类型，包括void。
3. **可以有参数**：构造方法可以带有参数，这些参数可以是任何类型，包括基本类型和引用类型。
4. **可以有多个**：一个类可以有多个构造方法，只要它们的参数列表不同（这被称为构造方法的重载）。
5. **自动调用**：当创建类的对象时，Java会自动调用与对象创建时提供的参数匹配的构造方法。
6. **可以访问类的私有成员**：构造方法可以访问类的私有成员，包括私有变量和私有方法。

在Java中，构造方法不能被覆盖（Override）。覆盖是面向对象编程中的一个概念，指的是子类可以提供一个与父类中方法名称、参数列表都相同的方法。当子类对象调用这个方法时，会执行子类中的实现，而不是父类中的实现。由于构造方法是用于初始化对象的，每个类都有自己特定的构造方法，因此不存在子类覆盖父类构造方法的情况。

注意，虽然构造方法不能被覆盖，但它们可以被继承。也就是说，子类可以继承父类的构造方法，但并不会直接继承。实际上，子类在创建对象时，会首先调用父类的构造方法（这可以通过super关键字实现），然后再执行子类自己的构造方法。
