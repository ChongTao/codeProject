# 1 为什么要使用多线程?

使用多线程的主要原因有以下几点：

1. 提高应用程序的响应能力：通过将耗时的操作放在单独的线程中执行，可以避免阻塞主线程，从而提高应用程序的响应能力。这对于需要同时处理多个用户请求或执行复杂计算的应用程序尤为重要。
2. 利用多核CPU资源：在多核CPU系统中，使用多线程可以将任务分配到不同的核心上执行，从而充分利用硬件资源，提高程序的执行效率。
3. 改善程序结构：一个复杂的应用程序可以划分为多个独立或半独立的运行部分，每个部分由一个线程来执行。这样可以使程序结构更加清晰，有利于理解和修改。
4. 方便的数据共享和通信：线程间共享进程的数据空间，这使得线程间的数据共享和通信变得简单和高效。通过线程间的协作，可以实现更复杂的任务和功能。

然而，需要注意的是，多线程编程也带来了一些挑战和复杂性，如线程同步、死锁、资源竞争等问题。因此，在使用多线程时需要谨慎处理这些问题，以确保程序的正确性和稳定性。

总之，使用多线程可以提高应用程序的性能、响应能力和可维护性，但同时也需要注意线程管理和同步的问题。在实际应用中，需要根据具体场景和需求来选择合适的线程使用策略。****

# 2 什么是线程死锁?如何避免死锁?

线程死锁是指两个或更多的线程在无限期地等待一个资源（例如锁），从而导致它们都无法继续执行。这通常发生在每个线程都持有一个资源，并请求获取另一个线程已持有的资源时，导致它们都在等待对方释放资源，从而形成了一个循环等待条件。

以下是四个可能导致死锁的必要条件，也被称为死锁的四个充分条件：

1. **互斥条件**：资源不能被共享，即一个资源一次只能被一个线程使用。
2. **持有并等待**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不可抢占**：资源不能被其他线程抢占，即资源只能由获得它的线程自己来释放。
4. **循环等待**：系统中若干个线程形成一种头尾相接的循环等待资源关系。

为了避免线程死锁，可以采取以下策略：

1. **避免一个线程同时获取多个锁**：如果可能，尽量让一个线程只获取一个锁。如果需要获取多个锁，考虑使用一次性获取所有锁的方法，而不是分步获取。
2. **避免在持有锁时等待获取其他锁**：如果一个线程已经持有一个锁，并需要获取另一个锁，考虑释放已持有的锁，然后再尝试获取所需的锁。
3. **尽量减少锁的持有时间**：一旦线程完成必要的操作并释放了锁，其他线程就可以立即获取该锁。
4. **设置锁的超时时间**：如果线程在获取锁时等待超时，则放弃获取锁，从而避免死锁。
5. **使用死锁检测工具**：例如 Java 的 `jstack` 工具，可以检测死锁线程的状态和调用栈信息，从而及时发现和解决死锁问题。
6. **使用避免死锁的算法和协议**：例如银行家算法等，这些算法和协议可以确保系统始终处于安全状态，从而避免死锁的发生。

# 3 如何预防和避免线程死锁?

避免线程死锁的方法有多种，下面列出了一些主要的策略：

1. **避免嵌套锁**：尽量避免在一个线程中，一个锁未释放就去请求另一个锁，这样容易导致死锁。如果确实需要多个锁，可以考虑一次性获取所有需要的锁，而不是分步获取。
2. **顺序锁获取**：如果多个线程需要获取多个锁，那么应该确保所有线程都按照相同的顺序去获取锁。这样可以避免循环等待条件，从而避免死锁。
3. **设置锁的超时时间**：在尝试获取锁的时候，可以设置一个超时时间。如果在这个时间内无法获取锁，那么就放弃获取，并释放已经占用的资源。这样可以避免线程无限期地等待一个资源，从而避免死锁。
4. **使用可重入锁**：可重入锁（如Java中的ReentrantLock）允许一个线程多次获取同一个锁，而不会导致死锁。
5. **使用死锁检测工具**：在开发过程中，可以使用一些死锁检测工具来检测程序中是否存在死锁的情况。这些工具可以帮助及时发现并解决问题。
6. **减小锁的粒度**：如果可能的话，尽量减小锁的粒度，即尽量只锁定必要的资源，而不是一大块代码或数据。这样可以减少线程间的竞争，从而降低死锁的概率。
7. **使用线程安全的数据结构和并发工具**：Java的`java.util.concurrent`包提供了许多线程安全的数据结构和并发工具，如`ConcurrentHashMap`，`BlockingQueue`等。这些工具已经内部处理了同步和并发问题，使用起来更安全，也可以降低死锁的风险。

# 4 为什么要用线程池

使用线程池的主要原因有以下几点：

1. **降低资源消耗**：通过重复利用已创建的线程，避免频繁地创建和销毁线程，从而减少系统资源的消耗，提高系统的性能和稳定性。
2. **提高响应速度**：当任务到达时，如果线程池中有空闲的线程，任务可以立即执行，而不需要等待线程创建，从而提高了系统的响应速度。
3. **提高线程的可管理性**：线程是稀缺资源，如果无限制地创建线程，不仅会消耗系统资源，还可能降低系统的稳定性。线程池可以对线程进行统一的分配、调优和监控，从而提高了线程的可管理性。
4. **更好地控制并发数**：线程池可以控制同时执行的线程数量，避免线程数过多导致系统过载。当线程数量超过最大数量时，超出的线程会排队等待，从而实现了对并发数的控制。

总之，使用线程池可以有效地提高系统的性能、稳定性和资源利用率，是处理大量短时间任务时的一种有效手段。

# 5 线程通信方式

线程通信是指线程之间传递数据或协调操作的过程。在Java中，线程通信可以通过几种方式实现：

1. **共享内存**：线程之间可以通过共享内存来交换数据。这通常涉及使用特殊的变量，如`volatile`变量或`synchronized`块，来确保线程间的可见性和同步。例如，一个线程可以修改共享变量的值，而其他线程可以读取或观察这个变量的变化。
2. **使用`wait()`和`notify()`方法**：这些是Java中内置的线程通信机制。`wait()`方法使当前线程等待，直到另一个线程调用同一个对象的`notify()`或`notifyAll()`方法。这通常用于实现线程间的协作和同步。
3. **使用`BlockingQueue`**：`BlockingQueue`是一个支持线程安全的队列，它可以在线程之间传递数据。生产者线程可以将数据放入队列，而消费者线程可以从队列中取出数据。这种机制常用于生产者-消费者模式。
4. **使用`Semaphore`**：`Semaphore`是一个计数器，可以用来控制多个线程对共享资源的访问。它常用于实现线程间的同步和互斥。
5. **使用`Future`和`Callable`**：`Callable`接口允许你返回一个结果，并且可以抛出一个受检查的异常。`Future`接口表示异步计算的结果。你可以将`Callable`提交给`ExecutorService`来异步执行，并通过`Future`获取结果。
6. **使用`Atomic`类**：Java的`java.util.concurrent.atomic`包提供了一些原子类，如`AtomicInteger`、`AtomicLong`等。这些类提供了线程安全的操作，可以在多线程环境下直接使用，而不需要额外的同步措施。

# 6 start与run区别

在Java中，`start`方法和`run`方法是线程（`Thread`）类的两个重要方法，它们在多线程编程中起着不同的作用，并具有显著的区别。

- `start`方法：用于启动一个新线程。当调用`start`方法时，Java虚拟机（JVM）会为这个线程分配必要的资源，并将线程的状态从新建（NEW）更改为就绪（RUNNABLE）。一旦线程获得CPU时间片，它将开始执行其`run`方法中的代码。
- `run`方法：是`Thread`类的一个普通方法，它包含了线程要执行的代码。直接调用`run`方法不会创建新线程，而是在当前线程（通常是主线程）中顺序执行`run`方法中的代码。

注意`start`方法一个线程只能被启动一次，如果尝试调用`start`方法，将会抛出`IllegalStateException`异常，这是因为一旦线程进入Runnable状态，就无法回退到New状态，查看源码可知，该`start`方法调用native的`start0`方法，该方法会请求系统分配线程资源。而`un`方法可以被重复调用，因为它只是一个普通方法。

# 7 sleep与wait区别

在Java中，`sleep`和`wait`是两个不同的方法，它们在功能、所属类、使用方式和唤醒方式上都有所区别。

1. **所属类不同**：`sleep`是`Thread`类中的方法，而`wait`是`Object`类中的方法。这意味着任何对象都可以调用`wait`方法，但只有线程对象才能调用`sleep`方法。
2. **功能不同**：`sleep`方法主要用于让当前线程暂停执行一段时间，不会释放任何锁资源。在这段时间内，其他线程可以继续执行。而`wait`方法则用于线程间的通信，调用`wait`方法的线程会放弃对象锁，进入等待状态，直到其他线程调用该对象的`notify`或`notifyAll`方法，该线程才会被唤醒并进入对象锁定池，准备获取对象锁进入运行状态。
3. **使用方式不同**：`sleep`方法可以在任何位置调用，而`wait`方法必须位于同步代码块或同步方法中，因为`wait`需要释放对象锁。此外，`wait`方法必须配合`synchronized`一起使用，否则会抛出`IllegalMonitorStateException`异常。
4. **唤醒方式不同**：`sleep`方法会在指定的时间后自动唤醒，不需要其他线程的干预。而`wait`方法则需要其他线程调用`notify`或`notifyAll`方法才能被唤醒。也就是说，`sleep`具有主动唤醒功能，而`wait`则只能被动地被唤醒。

总的来说，`sleep`和`wait`在Java中各有其用途和特点。`sleep`主要用于让线程暂停执行一段时间，而`wait`则用于线程间的通信和同步。在使用时，需要根据具体的需求和场景来选择合适的方法。

# 8 volatile 可以保证原子性么？

**volatile 关键字不能保证原子性**。尽管 volatile 可以确保变量的可见性和有序性（即禁止指令重排序），但它在处理复合操作（如自增、自减等）时无法保证原子性。原子性意味着一个操作是不可分割的，要么整个操作完成，要么没有完成。由于 `volatile` 变量的读写操作之间是可以被中断的，因此，在读取或者修改 `volatile` 变量的过程中，其他线程可能会对这个变量进行修改，导致数据的不一致性。

如果需要保证原子性，可以使用 Java 并发包中的 `AtomicXXX` 类，如 `AtomicInteger`、`AtomicLong` 等，这些类提供了原子操作的方法。另外，也可以使用锁机制，如 `synchronized` 关键字或 `java.util.concurrent.locks` 包中的锁实现，来确保复合操作的原子性。

总结来说，`volatile`关键字主要用于确保变量的可见性和有序性，但并不能保证原子性。在处理需要原子性保证的场景时，应使用其他机制来确保操作的原子性。

# 9 如何设定线程池的大小

设定线程池的大小是一个复杂的问题，因为它取决于许多因素，包括硬件架构、操作系统、应用程序的特性以及任务类型等。以下是一些常见的策略和建议：

1. **CPU密集型任务**：如果你的任务是CPU密集型的，即任务主要消耗CPU资源，那么线程池的大小应该接近或等于CPU的核数。因为CPU密集型任务会大量使用CPU资源，如果线程数过多，可能会导致CPU过度切换，从而降低效率。
2. **IO密集型任务**：如果你的任务是IO密集型的，即任务主要消耗IO资源，如网络或磁盘IO，那么线程池的大小可以设置为CPU核数的两倍。IO密集型任务在等待IO操作完成时会释放CPU，因此可以并行执行更多的线程。
3. **混合类型任务**：如果你的任务是混合类型的，即既包含CPU密集型任务，又包含IO密集型任务，那么线程池的大小需要根据实际情况进行调整。你可以尝试使用公式：最佳线程数 = （（线程等待时间 + 线程CPU时间）/ 线程CPU时间）* CPU核数，其中线程等待时间主要为IO时间。

以上都是基于一些常见场景的经验规则，实际设定线程池的大小时，还需要考虑其他因素，如系统的内存大小、网络带宽、磁盘速度等。而且，最好的方式是通过性能测试和调优来确定最佳的线程池大小。在实际应用中，可以通过逐步增加线程池的大小，观察系统的性能指标（如吞吐量、响应时间等）的变化，从而找到最优的线程池大小

# 10 为什么 wait() 方法不定义在 Thread 中

`wait()` 方法不定义在 `Thread` 类中，而是定义在 `Object` 类中，主要是出于设计和实现的考虑。在 Java 中，每个对象都有一个内置的锁，也称为监视器锁（monitor lock）。这个锁可以用于同步访问对象的状态。`wait()`、`notify()` 和 `notifyAll()` 这三个方法都是基于这个内置锁来工作的。

将这些方法定义在 `Object` 类中，而不是 `Thread` 类中，有几个原因：

1. **灵活性**：将 `wait()` 和 `notify()` 方法定义在 `Object` 类中，意味着任何对象都可以作为锁来使用。这样，我们就可以灵活地选择哪个对象来作为同步的锁，而不是仅仅局限于 `Thread` 对象。
2. **减少耦合**：将锁和线程分离，可以减少它们之间的耦合。这样，我们可以更容易地改变锁的实现，而不需要改变线程的实现。
3. **扩展性**：由于 `wait()` 和 `notify()` 方法定义在 `Object` 类中，因此它们可以用于任何对象，包括用户自定义的对象。这使得 Java 的并发编程模型更加灵活和可扩展。

需要注意的是，虽然 `wait()`、`notify()` 和 `notifyAll()` 方法定义在 `Object` 类中，但它们只能在同步块或同步方法中调用。这是因为这些方法需要访问对象的内置锁。如果在非同步块或方法中调用这些方法，将会抛出 `IllegalMonitorStateException` 异常。

# 11 tryLock和lock和lockInterruptibly的区别

`tryLock()`, `lock()`, 和 `lockInterruptibly()` 是 Java 中 `Lock` 接口中的三个方法，通常在实现线程同步时使用。这三个方法都用于获取锁，但它们的行为有所不同，尤其是在处理线程阻塞和中断时。以下是这三个方法的主要区别：

1. **tryLock()**:
   - `tryLock()` 方法尝试立即获取锁，如果锁立即可用并且是由当前线程获取的，则返回 `true`。
   - 如果锁不可用，则此方法将立即返回 `false`，而不会使当前线程阻塞。
   - 它可以用于非阻塞地尝试获取锁，而不会挂起当前线程。
   - `tryLock()` 方法还有一个重载版本 `tryLock(long time, TimeUnit unit)`，它允许指定一个超时时间，如果在这个时间内获取到了锁，就返回 `true`，否则返回 `false`。
2. **lock()**:
   - `lock()` 方法会阻塞当前线程，直到获取到锁为止。
   - 如果锁被其他线程持有，则当前线程将无限期地等待，直到获取到锁。
   - 在获取锁之前，线程将一直处于阻塞状态。
   - `lock()` 方法通常用于那些必须获取锁才能继续执行的代码段。
3. **lockInterruptibly()**:
   - `lockInterruptibly()` 方法与 `lock()` 方法类似，都会阻塞当前线程以获取锁。
   - 但是，如果当前线程在等待获取锁的过程中被中断（即调用了线程的 `interrupt()` 方法），则 `lockInterruptibly()` 会响应中断，抛出一个 `InterruptedException`。
   - 这允许在等待锁的过程中能够响应和处理线程中断。

- `tryLock()` 是非阻塞的，它立即尝试获取锁，如果获取不到锁就返回 `false`。
- `lock()` 是阻塞的，它会一直等待直到获取到锁。
- `lockInterruptibly()` 也是阻塞的，但它能够响应和处理线程中断，如果线程在等待锁的过程中被中断，它会抛出 `InterruptedException`。



在 Java 中，`Executors` 工具类提供了快速创建线程池的工厂方法（如 `newFixedThreadPool`、`newCachedThreadPool` 等），但这些方法在实际开发中**存在潜在风险**，因此通常不建议直接使用。以下是具体原因和替代方案：

------

### **1. 默认配置的潜在风险**

`Executors` 提供的默认线程池参数可能**不符合实际业务场景**，导致以下问题：

#### **(1) 无界队列导致内存溢出（OOM）**

- **问题示例**：
  `Executors.newFixedThreadPool(n)` 和 `Executors.newSingleThreadExecutor()` 使用 **无界队列**（`LinkedBlockingQueue`），当任务堆积速度超过处理速度时，队列无限增长，最终引发 `OutOfMemoryError`。

  java

  复制

  ```java
  // 隐患：无界队列
  ExecutorService executor = Executors.newFixedThreadPool(10);
  ```

#### **(2) 无限制线程数耗尽资源**

- **问题示例**：
  `Executors.newCachedThreadPool()` 的 `maximumPoolSize` 为 `Integer.MAX_VALUE`，允许无限制创建线程。在高并发场景下，可能瞬间耗尽系统资源。

  java

  复制

  ```
  // 隐患：线程数无上限
  ExecutorService executor = Executors.newCachedThreadPool();
  ```

#### **(3) 默认拒绝策略不友好**

- `Executors` 默认使用 `AbortPolicy`（直接抛出异常），可能导致任务丢失或系统不稳定。未根据业务需求选择合适的拒绝策略（如降级、日志记录等）。

------

### **2. 隐藏实现细节，无法灵活控制参数**

`Executors` 封装了线程池的构造过程，但**屏蔽了关键参数配置**，开发者无法根据业务需求调整：

- **核心参数不可控**：如核心线程数、最大线程数、队列类型、线程存活时间等。
- **队列类型固定**：无法选择其他队列类型（如优先级队列 `PriorityBlockingQueue`）。

------

### **3. 替代方案：手动创建线程池**

推荐直接使用 `ThreadPoolExecutor` 构造函数创建线程池，明确所有参数以规避风险：

#### **(1) 标准线程池创建示例**

```java
// 手动创建线程池
ExecutorService executor = new ThreadPoolExecutor(
    corePoolSize,     // 核心线程数（长期保留的线程）
    maxPoolSize,      // 最大线程数（根据负载动态调整）
    keepAliveTime,    // 非核心线程空闲存活时间
    TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(queueCapacity),  // 有界队列
    new CustomThreadFactory(),                // 自定义线程工厂
    new CustomRejectedExecutionHandler()      // 自定义拒绝策略
);
```

#### **(2) 参数配置建议**

| **参数**                   | **说明**                                                     |
| :------------------------- | :----------------------------------------------------------- |
| `corePoolSize`             | 根据 CPU 密集型或 I/O 密集型任务调整（如 `CPU 核数 + 1`）。  |
| `maxPoolSize`              | 根据系统负载和资源限制设置（如 `corePoolSize * 2`）。        |
| `workQueue`                | 使用有界队列（如 `ArrayBlockingQueue`）控制任务堆积上限，避免 OOM。 |
| `RejectedExecutionHandler` | 根据业务选择拒绝策略（如记录日志、降级处理、自定义重试）。   |

------

### **4. 推荐拒绝策略**

根据业务场景选择合适的拒绝策略：

1. **AbortPolicy**（默认）：直接抛出 `RejectedExecutionException`。
2. **CallerRunsPolicy**：由提交任务的线程直接执行任务。
3. **DiscardPolicy**：静默丢弃新任务。
4. **DiscardOldestPolicy**：丢弃队列中最旧的任务，尝试重新提交新任务。
5. **自定义策略**：如记录日志、异步重试、降级处理。

------

### **5. 通过线程池监控优化**

手动创建线程池后，可结合监控工具（如 Spring Boot Actuator、Micrometer）跟踪关键指标：

- **活跃线程数**：`executor.getActiveCount()`
- **队列大小**：`executor.getQueue().size()`
- **任务完成数**：`executor.getCompletedTaskCount()`

------

### **总结**

| **方式**                      | **优点**           | **缺点**                            | **适用场景**         |
| :---------------------------- | :----------------- | :---------------------------------- | :------------------- |
| `Executors` 工厂方法          | 快速创建，代码简洁 | 参数不可控，存在 OOM 和资源耗尽风险 | 简单测试、临时验证   |
| 手动创建 `ThreadPoolExecutor` | 参数透明，灵活可控 | 代码稍复杂                          | 生产环境、高并发场景 |

遵循以下原则：

1. **使用有界队列**：明确队列容量，防止任务无限堆积。
2. **合理设置线程数**：根据任务类型（CPU/I/O 密集型）调整核心和最大线程数。
3. **定义拒绝策略**：确保任务被合理处理，避免直接丢弃或抛出异常。
4. **监控和调优**：动态调整参数以适应业务变化。
