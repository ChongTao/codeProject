# ReentrantLock与 synchronized 区别

`Synchronized`和`ReentrantLock`在Java中都是用来控制多个线程对共享资源的访问，但它们在实现方式、功能和性能等方面存在一些区别。

1. **实现方式**：
   - **Synchronized**：是Java语言内置的关键字，由JVM解释器锁实现。它不需要显式地声明和释放锁，而是由编译器自动插入相应的锁操作。
   - **ReentrantLock**：是Java提供的锁框架中的一个实现类，基于AQS（AbstractQueuedSynchronizer）实现。它需要显式地通过`lock()`和`unlock()`方法来获取和释放锁。
2. **等待可中断性**：
   - **Synchronized**：不支持等待线程的中断，即使线程在等待锁的过程中被中断，它也会继续等待锁的释放。
   - **ReentrantLock**：支持等待线程的中断。如果线程在等待锁的过程中被中断，它会收到一个`InterruptedException`，从而可以选择退出等待。
3. **锁的释放**：
   - **Synchronized**：在发生异常时，JVM会自动释放线程占有的锁，因此不会导致死锁现象发生。
   - **ReentrantLock**：在发生异常时，如果没有主动通过`unlock()`方法释放锁，则可能导致死锁现象。因此，使用ReentrantLock时需要在finally块中释放锁。
4. **公平性**：
   - **Synchronized**：无法保证锁的公平性，即先请求锁的线程不一定先获得锁。
   - **ReentrantLock**：可以通过构造函数指定锁的公平性。如果设置为公平锁，则先请求锁的线程会先获得锁；如果设置为非公平锁，则可能出现后请求锁的线程先获得锁的情况。
5. **性能**：
   - **Synchronized**：是JVM层面的锁，由于它的实现是由编译器和JVM共同完成的，因此在某些情况下可能具有更好的性能。
   - **ReentrantLock**：是API层面的锁，需要显式地声明和释放锁，因此在使用上可能稍微复杂一些。但是，由于其提供了更多的功能和灵活性，因此在某些场景下可能具有更好的性能。

| **特性**       | **ReentrantLock**                       | **synchronized**         |
| :------------- | :-------------------------------------- | :----------------------- |
| **锁获取方式** | 显式调用 `lock()`/`unlock()`            | 隐式（代码块或方法）     |
| **公平性**     | 支持公平与非公平                        | 仅非公平                 |
| **可中断性**   | 支持（`lockInterruptibly()`）           | 不支持                   |
| **超时机制**   | 支持（`tryLock()`）                     | 不支持                   |
| **条件变量**   | 支持多个 `Condition`                    | 单一 `wait()`/`notify()` |
| **性能**       | 高竞争场景下更优（Java 6+ 后两者接近）  | 低竞争场景更简洁         |
| **异常处理**   | 需手动释放锁（`finally` 中 `unlock()`） | 自动释放                 |

# Callable 和 Future区别

`Callable`和`Future`是Java中用于处理异步计算和结果获取的两种重要机制。

`Callable`接口是一个任务执行器接口，它定义了一个call()方法，这个方法可以返回一个结果，也可以抛出异常。`Callable`接口常常用在多线程编程中，用来表示一个需要执行的任务。而Future接口是一个代表异步计算结果的抽象，它代表一个可能还没有完成的任务。调用Future的get()方法会阻塞当前线程，直到任务完成并返回结果。

总的来说，Callable和Future是Java中处理异步计算和结果获取的重要工具，它们可以帮助开发者更好地处理并发和异步任务。Callable可以返回一个Future对象，这样就可以在Callable任务完成之后获取结果

# ThreadLocal作用

ThreadLocal是Java中的一个类，它提供了线程本地变量。这些变量不同于它们的正常变量，因为每个访问该变量的线程都有其自己的、独立初始化的变量副本。`ThreadLocal`实例通常作为静态字段出现在类中，以关联线程和线程上下文。ThreadLocal的主要作用包括：

1. **解决多线程并发问题**：在多线程环境中，多个线程可能会同时访问和修改同一个变量，这可能会导致数据不一致或其他并发问题。通过使用ThreadLocal，每个线程都可以拥有自己独立的变量副本，从而避免了这些问题。
2. **减少参数传递的复杂度**：在多线程程序中，一个线程可能需要调用多个方法或组件，而这些方法或组件可能需要访问某些公共变量。如果将这些变量作为参数在每个方法调用中传递，可能会导致代码变得复杂且难以维护。通过使用ThreadLocal，可以将这些变量存储在每个线程的本地存储中，从而避免了这种复杂性。
3. **管理数据库连接、Session等**：在使用数据库连接、Session等资源时，通常需要每个线程都有自己独立的实例。通过使用ThreadLocal，可以轻松地为每个线程创建和管理这些资源，而无需担心线程安全问题。

需要注意的是，虽然ThreadLocal在某些情况下非常有用，但它也可能导致内存泄漏等问题。因此，在使用ThreadLocal时，需要谨慎考虑其适用场景，并遵循最佳实践。

# ThreadLocal 内存泄露问题是怎么导致的？

ThreadLocal内存泄漏问题主要是由于不合理的使用导致的。具体来说，`ThreadLocal`的内存泄漏主要发生在以下两种情况：

1. **静态ThreadLocal变量**：如果ThreadLocal变量被声明为static，那么它将在类加载时初始化，并且由于static变量的生命周期与类加载器相同，这将导致ThreadLocal变量在整个应用程序运行期间都存在。如果应用程序长时间运行并且不断地创建新的线程，那么每个线程都将在自己的ThreadLocalMap中持有该变量的一个引用，这将导致大量的内存消耗，并最终可能引发内存泄漏。
2. **未及时清理**：当使用完ThreadLocal变量后，如果没有及时调用其remove()方法将其从ThreadLocalMap中移除，那么即使该线程已经结束，其对应的ThreadLocalMap中的Entry也不会被清理，因为Entry的Key（即ThreadLocal对象）是弱引用，它不会阻止Entry被垃圾回收，但Entry的Value（即线程变量）却仍然是一个强引用，这将导致Value无法被垃圾回收，从而引发内存泄漏。

为了避免ThreadLocal的内存泄漏问题，我们可以采取以下措施：

1. **避免使用静态ThreadLocal变量**：除非确实需要，否则尽量避免使用静态ThreadLocal变量，以减少内存消耗和潜在的内存泄漏风险。
2. **及时清理**：每次使用完ThreadLocal变量后，及时调用其remove()方法将其从ThreadLocalMap中移除，以避免内存泄漏。
3. **使用try-finally块**：为了确保在发生异常的情况下也能正确地清理ThreadLocal变量，可以使用try-finally块来确保remove()方法的调用。
