# 1 介绍一下Java 中的几种基本数据类型和大小

Java中的基本数据类型共有8种，它们可以分为4类：整数型、浮点型、布尔型和字符型。

- 整数型：包括byte、short、int和long。
- 浮点型：包括float和double。
- 布尔型：boolean，只有两个取值，true和false。
- 字符型：char，占用2个字节（16位），可以表示一个16位Unicode字符。

| 类型    | 名称         | 大小    | 范围                                     |
| ------- | ------------ | ------- | ---------------------------------------- |
| byte    | 字节         | 1个字节 | -128~127                                 |
| short   | 短整型       | 2个字节 | -32768~32767                             |
| int     | 整型         | 4个字节 | -2147483648~2147483647                   |
| long    | 长整型       | 8个字节 | -9223372036854775808~9223372036854775807 |
| float   | 单精度浮点型 | 4个字节 | ±3.4e-38到±3.4e+38                       |
| double  | 双精度浮点型 | 8个字节 | ±4.9e-324到±1.8e+308                     |
| boolean | 布尔         | 1个字节 | true或者false                            |
| char    |      字符     |   2个字节         |    0~ 65535                                      |

# 2 基本类型和包装类型的区别

Java中的基本类型和包装类型之间存在几个主要的区别：

1. **存储和内存布局**：基本类型直接存储值，它们有固定的存储空间大小，并且这个大小不会随机器硬件架构的变化而变化。这使得Java程序比其他大多数语言编写的程序更具可移植性。另一方面，包装类型是对象，它们存储在堆内存中，并且有一个额外的引用开销。
2. **初始值**：基本类型的变量在声明时会被自动初始化为其类型的默认值（例如，int的默认值为0，boolean的默认值为false）。然而，包装类型的变量在声明时不会自动初始化，它们的初始值为null。
3. **传递方式**：基本类型是按值传递的，这意味着当你将一个基本类型的变量传递给一个方法时，实际上是传递了该变量的副本，原始变量的值不会改变。相反，包装类型是按引用传递的，这意味着当你将一个包装类型的变量传递给一个方法时，实际上是传递了对该对象的引用的副本，原始对象的状态可能会在方法中被改变。
4. **方法和字段**：包装类型作为对象，可以拥有方法和字段。这使得包装类型可以进行更复杂的操作，例如Integer类有一个方法`intValue()`可以将Integer对象转换为int基本类型。
5. **空值**：包装类型可以为null，而基本类型不可以。这是因为基本类型只有值，而包装类型有一个非功能值：null。
6. **集合使用**：在Java的集合框架中（如Collection和Map），由于集合只能存储对象，因此基本类型不能直接用于集合。相反，包装类型可以被用于集合。

# 3 为什么浮点数运算的时候会有精度丢失的风险？

浮点数在运算时出现精度丢失的风险，主要源于计算机的二进制浮点数表示方式和有限存储空间的限制。

二进制无法精确表示某些十进制小数，如十进制的 **0.1** 在二进制中是一个无限循环小数。计算机只能用有限的位数（如单精度 23 位、双精度 52 位）存储浮点数，导致**截断或舍入**，最终存储的是近似值。

解决方案使用**`BigDecimal`**计算精确的值。

# 4 介绍一下自动装箱与拆箱原理

自动装箱与拆箱是Java语言中的一个特性，它允许开发者在基本类型（如int、double等）和它们对应的包装类型（如Integer、Double等）之间自动转换，而无需显式地进行类型转换。这一特性在Java 5及以上版本中得到支持，主要归功于Java编译器在编译时自动插入了相应的装箱和拆箱代码。

## 4.1自动装箱

将基本类型的值自动转换为对应的包装类型。例如，当一个int类型的值被赋值给一个Integer类型的变量时，Java编译器会自动将int类型的值装箱为一个Integer对象。这个过程是隐式的，开发者无需编写额外的装箱代码。

## 4.2 自动拆箱

将包装类型的对象自动转换为对应的基本类型。例如，当一个Integer类型的对象被赋值给一个int类型的变量时，Java编译器会自动将Integer对象拆箱为int类型的值。同样，这个过程也是隐式的，无需开发者显式地进行拆箱操作。

自动装箱与拆箱的原理在于Java编译器在编译阶段对代码进行了优化。当编译器遇到基本类型和包装类型之间的赋值操作时，它会自动插入相应的装箱或拆箱代码，以确保类型的兼容性。这种优化使得开发者在编写代码时可以更加简洁和高效，无需关心基本类型和包装类型之间的转换细节。需要注意的是，虽然自动装箱和拆箱可以带来编程的便利性，但在某些情况下也可能导致性能问题或意外的结果。例如，在进行大量基本类型和包装类型之间的转换时，自动装箱和拆箱可能会产生额外的对象创建和销毁开销。此外，由于自动装箱和拆箱是隐式的，有时可能会导致空指针异常（NullPointerException）等问题。因此，在使用自动装箱和拆箱时，开发者仍然需要保持谨慎和注意代码的正确性。

# 5 介绍String、StringBuffer、StringBuilder区别

1. 可变性：String类的内容是不可变的，每次对String的操作都会生成新的String对象，这不仅效率低下，而且浪费大量的内存空间。而StringBuffer和StringBuilder类的内容是可变的，当对它们进行修改时，不会生成新的对象，而是直接在原有对象上进行修改，因此效率更高。
2. 线程安全：StringBuffer是线程安全的，可以在多线程环境下安全使用。而StringBuilder则是线程不安全的，不能同步访问，因此在非多线程操作并且有大量的字符串拼接、插入、删除操作时，使用StringBuilder会有更好的性能。
3. 性能：在性能方面，StringBuilder相较于StringBuffer有速度优势，因此在多数情况下建议使用StringBuilder类。不过，如果在需要线程安全的情况下，则应该使用StringBuffer。

# 6 字符串拼接用“+” 还是 StringBuilder

在Java中，字符串拼接可以通过多种方式实现，包括使用"+"运算符和StringBuilder类。选择哪种方式取决于具体的使用场景和性能要求。

对于少量的字符串拼接操作，使用"+"运算符通常是简单且方便的。例如，拼接两个或三个字符串时，使用"+"运算符可以简洁地完成任务。然而，当涉及到大量的字符串拼接操作时，使用`StringBuilder`类通常更为高效。`StringBuilder`类提供了一个可变的字符串缓冲区，允许在不需要创建新对象的情况下进行字符串的拼接。这避免了频繁的内存分配和垃圾回收，从而提高了性能。需要注意的是，在某些情况下，编译器会自动优化使用"+"运算符的字符串拼接。当编译器能够确定字符串拼接操作的数量是固定的且较小时，它可能会将多个"+"运算符连接的字符串字面量合并为一个单独的字符串字面量，从而避免了创建额外的StringBuilder对象。然而，这种优化并不适用于所有情况，特别是对于动态生成的字符串或循环中的字符串拼接操作。在这些情况下，手动使用StringBuilder通常是更好的选择。

# 7 String s1 = new String("abc");这句话创建了几个字符串对象？

这句代码 `String s1 = new String("abc");` 在Java中创建了两个字符串对象。

1. 第一个对象是字面量字符串 `"abc"`。这个字符串对象被存储在Java的字符串常量池中。字符串常量池是一个特殊的内存区域，用于存储字符串字面量。当创建一个字符串字面量时，JVM首先会检查字符串常量池中是否已经存在相同的字符串。如果存在，就返回对该字符串的引用；如果不存在，就在字符串常量池中创建一个新的字符串对象。
2. 第二个对象是通过 `new String("abc")` 创建的。这个对象是在堆内存中分配的，而不是在字符串常量池中。即使 `"abc"` 这个字符串已经存在于字符串常量池中，使用 `new` 关键字仍然会在堆内存中创建一个新的字符串对象。

因此，这句代码总共创建了两个字符串对象：一个在字符串常量池中，另一个在堆内存中。变量 `s1` 引用的是堆内存中的那个对象。



# 8 String 类型的变量和常量做“+”运算时发生了什么？

在Java中，当使用`+`运算符对`String`类型的变量或常量进行运算时，会发生字符串的拼接。这个操作在Java中是通过`StringBuilder`（或`StringBuffer`，在同步上下文中）类来实现的，尽管这个实现细节对程序员来说是透明的。

下面是几种情况，解释了`String`类型的变量和常量做`+`运算时发生了什么：

1. **常量与常量拼接**： 如果两个操作数都是字符串字面量（常量），编译器会在编译时优化这个操作，直接将两个字符串常量连接成一个新的字符串常量，并存储在字符串常量池中。

   ```
   String s1 = "Hello" + "World"; // 编译时优化为 "HelloWorld"
   ```

2. **常量与变量拼接**： 如果其中一个操作数是字符串字面量（常量），而另一个操作数是字符串变量，那么编译器会创建一个`StringBuilder`（或`StringBuffer`）对象，并将常量字符串作为初始值放入该对象中，然后将变量字符串追加到该对象中。最后，通过调用`toString()`方法将结果转换为字符串。

   ```
   String variable = "World";
   String s2 = "Hello" + variable; // 使用StringBuilder进行拼接
   ```

3. **变量与变量拼接**： 如果两个操作数都是字符串变量，那么编译器同样会创建一个`StringBuilder`对象，并将两个变量的值追加到该对象中。最后，通过调用`toString()`方法将结果转换为字符串。

   ```
   String variable1 = "Hello";
   String variable2 = "World";
   String s3 = variable1 + variable2; // 使用StringBuilder进行拼接
   ```

4. **非字符串类型与字符串拼接**： 如果其中一个操作数是字符串，而另一个操作数是其他类型的变量（如`int`、`double`、`boolean`等），那么编译器会先将非字符串类型转换为字符串，然后使用`StringBuilder`进行拼接。

   ```
   int number = 123;
   String s4 = "The number is " + number; // number被转换为字符串"123"，然后进行拼接
   ```

在所有这些情况下，最终的结果都是一个新的`String`对象，它包含了拼接后的字符串内容。需要注意的是，尽管`+`运算符在语法上看起来像是直接操作字符串，但实际上它背后涉及到了`StringBuilder`（或`StringBuffer`）类的使用，以及可能的内存分配和垃圾回收。因此，在需要频繁进行字符串拼接的场合，手动使用`StringBuilder`通常会更高效。

# 9 String#equals()` 和 `Object#equals()区别

## 9.1 Object#equals()

- `Object` 类是Java中所有类的根类。`Object` 类中的 `equals()` 方法提供了一个默认的实现，该实现基于对象的内存地址（即对象的引用）来比较对象是否相等。如果两个引用指向同一个对象，那么它们被认为是相等的。这个默认实现通常被重写，以便在子类中提供更有意义的比较逻辑。
- Object#equals()的契约要求：

  - 如果对象自身与另一个对象相等，则返回 `true`。
  - 如果对象自身与另一个对象不相等，则返回 `false`。
  - 对称性：如果 `x.equals(y)` 返回 `true`，那么 `y.equals(x)` 也应该返回 `true`。
  - 反射性：对于任何非空引用值 `x`，`x.equals(null)` 必须返回 `false`。
  - 传递性：如果 `x.equals(y)` 返回 `true`，并且 `y.equals(z)` 返回 `true`，那么 `x.equals(z)` 也应该返回 `true`。
  - 一致性：对于任何非空引用值 `x` 和 `y`，只要 `equals` 比较操作在应用程序的执行期间对相应的信息没有修改，多次调用 `x.equals(y)` 始终返回 `true` 或始终返回 `false`。

## 9.2 String#equals()

- `String` 类重写了 `Object` 类中的 `equals()` 方法，以提供基于字符串内容的比较。
- 当使用 `String#equals()` 方法时，它会比较两个字符串的内容是否相同，而不是比较它们的内存地址。
- String#equals()的实现满足了 `Object#equals()` 的契约，并且提供了额外的特性，如区分大小写（通过 `equalsIgnoreCase()` 方法）的比较。

# 10 介绍一下包装类型的缓存机制

Java中的包装类型（如Integer、Long、Boolean等）具有一种称为“缓存机制”或“缓存池”（Cache Pool）的特性。这种机制主要是为了提高性能和节省内存。

具体来说，缓存机制的实现方式是在类初始化时，对于某些常用的数值范围（如Integer类型的范围是-128至127，Long类型的范围类似），会预先创建并缓存这些数值对应的包装类型对象。当需要创建新的包装类型对象时，Java会先检查缓存池中是否已经存在相同值的对象。如果存在，就直接返回缓存中的对象，而不是创建新的对象。这样可以减少对象的创建和销毁，节省内存和垃圾回收的开销。

需要注意的是，这种缓存机制是由Java虚拟机（JVM）实现的，而不是由Java语言规范定义的。因此，对于超出缓存池范围的数值，JVM仍然会创建新的包装类型对象。此外，只有在使用自动装箱（即编译器自动将基本类型转换为包装类型）时，缓存机制才会生效。如果使用构造函数直接创建包装类型对象，那么无论数值大小，都会创建新的对象。

