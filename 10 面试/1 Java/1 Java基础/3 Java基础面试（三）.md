# 1 介绍一下深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

深拷贝和浅拷贝是两种不同的数据复制方式，它们在处理对象或数据结构时有着不同的行为。

## 1.1 浅拷贝

浅拷贝是指创建一个新对象，并将原始对象的属性值复制到新对象中。如果属性值是基本类型（如数值、布尔值、字符串等），那么会直接复制值；如果属性值是引用类型（如数组、对象等），那么只会复制内存地址，而不是实际的对象。这意味着原始对象和其拷贝对象会共享相同的内部对象，对其中一个对象的修改会影响到另一个对象。

## 1.2 深拷贝

深拷贝是指创建一个新对象，并将原始对象的所有属性值都复制到新对象中，包括嵌套的对象和数组。在深拷贝过程中，会递归地复制所有内部对象，并在堆内存中创建新的内存空间来存储复制的对象。这意味着原始对象和其拷贝对象是完全独立的，对其中一个对象的修改不会影响到另一个对象。

# 2 hashCode 作用

在 Java 中，hashCode() 方法的主要作用是为对象生成一个整数哈希值，用于支持基于哈希表的数据结构（如 HashMap、HashSet、Hashtable）的高效操作。其核心作用是快速定位对象在哈希表中的位置。

- 哈希表原理：哈希表通过 hashCode() 计算对象的哈希值，将其映射到数组（桶）的特定索引位置，从而实现快速插入和快速查找。

## 2.1 hashCode() 和 equals()

- 一致性：若两个对象通过 equals() 比较相等，它们的 hashCode() 必须返回相同的值。

- 非唯一性：不同对象可以返回相同的哈希值（哈希碰撞），但应尽量均匀分布以减少碰撞概率。

# 3 为什么要有 hashCode

`hashCode()` 方法在 Java 中具有重要的作用，主要体现在以下几个方面：

1. **性能优化**：`hashCode()` 方法用于在哈希表（如 HashMap、HashSet 等）中快速定位对象。通过计算对象的哈希码值，哈希表可以直接将对象映射到其存储位置，从而避免了遍历整个数据结构。这使得查找、添加或删除对象的操作复杂度接近 O(1)，大大提高了性能。
2. **散列分布**：良好的 `hashCode()` 实现会尽量产生均匀分布的哈希码值，这有助于减少哈希冲突。当哈希冲突较少时，哈希表的操作复杂度更加接近理论上的最佳值。通过减少哈希冲突，`hashCode()` 方法有助于提高哈希表的整体性能。
3. **一致性要求**：根据 Java 的合同要求，如果两个对象根据 `equals()` 方法是相等的，那么它们的 `hashCode()` 方法必须返回相同的值。这有助于确保哈希表可以正确存储和检索对象。当覆盖一个类的 `equals()` 方法时，通常需要同时覆盖 `hashCode()` 方法，以确保两者行为的一致性。

总之，`hashCode()` 方法的存在是为了提高哈希表等数据结构的性能，通过快速定位对象在哈希表中的存储位置，减少哈希冲突，以及确保 `equals()` 和 `hashCode()` 方法的一致性。这些特性使得 `hashCode()` 方法在 Java 中具有不可替代的作用。

# 4 为什么重写 equals() 时必须重写 hashCode() 方法？

在 Java 中，重写 equals() 方法时必须同时重写 hashCode() 方法，这是由 Java 规范中对象一致性契约强制要求的。如果违反这一规则，会导致基于哈希表的数据结构（如 HashMap、HashSet）出现不可预期的行为。

## 3.1 Java 对象的契约规则
Java 规范明确规定了 equals() 和 hashCode() 必须满足以下条件：

- 一致性：如果两个对象通过 equals() 判断为相等（a.equals(b) == true），那么它们的 hashCode() 必须返回相同的值。反之，如果两个对象的 hashCode() 相同，它们的 equals() 不一定相等（允许哈希碰撞）。

- 默认实现的问题：Object 类的默认 equals() 比较内存地址（==），而默认 hashCode() 生成与内存地址相关的值。如果仅重写 equals() 不重写 hashCode()，逻辑相等的对象可能哈希值不同，破坏契约。

## 3.2 对哈希集合（如 HashSet）的影响

HashSet 内部使用 HashMap 实现，依赖 hashCode() 和 equals() 去重。
