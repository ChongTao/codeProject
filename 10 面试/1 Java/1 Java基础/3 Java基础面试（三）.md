# 1 介绍一下深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

深拷贝和浅拷贝是两种不同的数据复制方式，它们在处理对象或数据结构时有着不同的行为。

## 1.1 浅拷贝

浅拷贝是指创建一个新对象，并将原始对象的属性值复制到新对象中。如果属性值是基本类型（如数值、布尔值、字符串等），那么会直接复制值；如果属性值是引用类型（如数组、对象等），那么只会复制内存地址，而不是实际的对象。这意味着原始对象和其拷贝对象会共享相同的内部对象，对其中一个对象的修改会影响到另一个对象。

## 1.2 深拷贝

深拷贝是指创建一个新对象，并将原始对象的所有属性值都复制到新对象中，包括嵌套的对象和数组。在深拷贝过程中，会递归地复制所有内部对象，并在堆内存中创建新的内存空间来存储复制的对象。这意味着原始对象和其拷贝对象是完全独立的，对其中一个对象的修改不会影响到另一个对象。

# 2 hashCode 作用

在 Java 中，hashCode() 方法的主要作用是为对象生成一个整数哈希值，用于支持基于哈希表的数据结构（如 HashMap、HashSet、Hashtable）的高效操作。其核心作用是快速定位对象在哈希表中的位置。

- 哈希表原理：哈希表通过 hashCode() 计算对象的哈希值，将其映射到数组（桶）的特定索引位置，从而实现快速插入和快速查找。

## 2.1 hashCode() 和 equals()

- 一致性：若两个对象通过 equals() 比较相等，它们的 hashCode() 必须返回相同的值。

- 非唯一性：不同对象可以返回相同的哈希值（哈希碰撞），但应尽量均匀分布以减少碰撞概率。

# 3 为什么重写 equals() 时必须重写 hashCode() 方法？

在 Java 中，重写 equals() 方法时必须同时重写 hashCode() 方法，这是由 Java 规范中对象一致性契约强制要求的。如果违反这一规则，会导致基于哈希表的数据结构（如 HashMap、HashSet）出现不可预期的行为。以下是具体原因和实际影响：

## 3.1 Java 对象的契约规则
Java 规范明确规定了 equals() 和 hashCode() 必须满足以下条件：

- 一致性：如果两个对象通过 equals() 判断为相等（a.equals(b) == true），那么它们的 hashCode() 必须返回相同的值。反之，如果两个对象的 hashCode() 相同，它们的 equals() 不一定相等（允许哈希碰撞）。

- 默认实现的问题：Object 类的默认 equals() 比较内存地址（==），而默认 hashCode() 生成与内存地址相关的值。如果仅重写 equals() 不重写 hashCode()，逻辑相等的对象可能哈希值不同，破坏契约。

## 3.2 对哈希集合（如 HashSet）的影响

HashSet 内部使用 HashMap 实现，依赖 hashCode() 和 equals() 去重。

# 4 serialVersionUID作用

serialVersionUID是Java中序列化机制的一部分，用于**验证版本一致性**。在进行序列化操作时，serialVersionUID用于标识当前对象的版本，并将其写入到序列化文件中。当反序列化时，JVM会将文件中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同，则认为版本一致，可以进行反序列化；否则，会抛出序列化版本不一致的异常。

