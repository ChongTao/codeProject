# 介绍一下List, Set, Queue, Map

List、Set、Queue和Map都是Java中的接口，用于处理不同种类的数据集合，它们之间的主要区别如下：

1. List（列表）：
   - 存储的元素是有序的，可以重复。
   - 元素在列表中的位置可以通过索引访问，类似于数组。
   - 常见的实现类有ArrayList和LinkedList，其中ArrayList提供了快速随机访问的能力，而LinkedList更擅长插入和删除操作。
2. Set（集合）：
   - 存储的元素是无序的，不可重复。
   - 不支持索引访问，通常通过迭代器遍历其元素。
   - 常见的实现类有HashSet和TreeSet，其中HashSet基于哈希表提供高效的查找、插入和删除操作，而TreeSet则保持了内部排序，可以进行顺序遍历或根据指定比较器进行排序。
3. Queue（队列）：
   - 遵循先进先出（FIFO）原则，存储的元素是有序的，可以重复。
   - 除了基本的FIFO特性外，还有其他类型的队列，如优先队列（PriorityQueue），其中元素按照自然顺序或自定义比较器提供的顺序进行排序。
   - 常见的实现类有LinkedList、ArrayDeque和PriorityQueue等。
4. Map（映射）：
   - 使用键值对（key-value）存储，其中key是无序的、不可重复的，value是无序的、可以重复的。
   - 每个键最多映射到一个值。
   - 不支持索引访问，但可以通过键来获取相应的值。
   - 常见的实现类有HashMap、TreeMap和LinkedHashMap等，其中HashMap提供常数时间复杂度的平均查找性能，TreeMap基于红黑树实现了键的排序，而LinkedHashMap在HashMap的基础上还维护了元素插入顺序。


# ArrayList 可以添加 null 值吗?

`ArrayList` 在 Java 中可以添加 `null` 值。`ArrayList` 是一个对象列表，可以存储任何类型的对象，包括 `null`。实际上，`ArrayList` 的内部实现就是一个动态数组，它使用一个 `Object[]` 数组来存储元素，而这个数组是可以包含 `null` 值的。

#  ArrayList 插入和删除元素的时间复杂度

`ArrayList` 在 Java 中插入和删除元素的时间复杂度取决于操作的具体位置和类型。

1. **在末尾插入或添加元素**：
   - 时间复杂度：O(1)
   - 说明：`ArrayList` 有一个内部数组，当在末尾添加元素时，通常只需要更新一个指向新大小的变量，并将新元素放在数组的最后一个位置。因此，这个操作的时间复杂度是常数时间。
2. **在开头插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：当在 `ArrayList` 的开头插入或删除元素时，所有现有的元素都需要移动一位。这是因为内部数组需要复制所有元素来保持连续性。因此，这个操作的时间复杂度是线性的，其中 n 是 `ArrayList` 的大小。
3. **在中间插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：在 `ArrayList` 的中间位置插入或删除元素也需要移动元素来保持连续性。具体来说，插入元素时，所有从插入点到数组末尾的元素都需要后移一位；删除元素时，所有从删除点到数组末尾的元素都需要前移一位。因此，这个操作的时间复杂度也是线性的。

#  LinkedList 插入和删除元素的时间复杂度

`LinkedList` 在 Java 中插入和删除元素的时间复杂度取决于操作的位置。

1. **在开头或末尾插入或删除元素**：
   - 时间复杂度：O(1)
   - 说明：`LinkedList` 使用双向链表来存储元素。在链表的开头或末尾添加或删除元素只需要更新几个指针，不需要移动其他元素。因此，这些操作的时间复杂度是常数时间。
2. **在中间插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：当在链表的中间位置插入或删除元素时，需要遍历链表直到找到要插入或删除的位置。这个遍历过程的时间复杂度是线性的，因为它依赖于链表中要到达的节点的位置。一旦找到位置，插入或删除操作本身的时间复杂度是 O(1)，因为它只涉及更新几个指针。

总的来说，`LinkedList` 在插入和删除元素时，特别是在链表的开头和末尾，通常比 `ArrayList` 更高效。然而，`LinkedList` 在访问元素时的性能较差，因为访问特定位置的元素需要遍历链表，其时间复杂度是 O(n)。因此，在选择 `ArrayList` 还是 `LinkedList` 时，应根据具体的使用场景和需求来权衡。

# HashSet 如何检查重复

`HashSet` 是 Java 中的一个类，它实现了 `Set` 接口，用于存储不重复的元素。`HashSet` 内部使用一个 `HashMap` 来存储元素，其中元素作为键（Key），而值（Value）通常是一个常量（例如 `PRESENT`）。由于 `HashMap` 的键是唯一的，因此 `HashSet` 能够确保存储的元素也是唯一的。

当你尝试向 `HashSet` 中添加一个元素时，`HashSet` 会使用元素的 `hashCode()` 方法来计算该元素的哈希码，并基于这个哈希码来确定元素在 `HashMap` 中的存储位置。然后，`HashSet` 会检查该位置是否已经有元素存在。如果存在，它会使用 `equals()` 方法来比较新元素与已存在元素是否相等。如果相等，则新元素不会被添加到 `HashSet` 中，因为 `HashSet` 不允许重复元素。如果不相等，那么新元素会替换已存在的元素，因为 `HashMap` 的键是唯一的。

因此，`HashSet` 检查重复的方式是基于元素的 `hashCode()` 和 `equals()` 方法。首先，它使用 `hashCode()` 方法来确定元素在 `HashMap` 中的存储位置。然后，它使用 `equals()` 方法来比较新元素与已存在元素是否相等。如果两个方法都返回相同的结果，那么 `HashSet` 就认为这两个元素是重复的。

# Hashtable和HashMap区别

`HashTable`和`HashMap`都是Java中用于存储键值对的集合类，但它们之间存在一些重要的区别：

1. **线程安全性**：`Hashtable`是线程安全的，因为它的大多数方法都是同步的，可以在多线程环境中安全使用。而`HashMap`是非线程安全的，它的方法不是同步的，因此在多线程环境中使用时需要额外的同步措施。

2. **效率**：由于`Hashtable`是线程安全的，其性能通常比非线程安全的`HashMap`低。因为同步操作会带来额外的开销。然而，如果你的应用程序是单线程的，或者你可以通过其他方式（如使用`Collections.synchronizedMap()`方法）来同步`HashMap`，那么`HashMap`的性能可能会更高。

3. **对null的支持**：`HashMap`允许使用`null`作为键（key）和值（value），但键只能有一个`null`，而可以有多个键所对应的值为`null`。相比之下，`Hashtable`不允许使用`null`作为键或值。

4. **扩容方式**：在不指定容量的情况下，`HashTable`的默认容量为11，而`HashMap`的默认容量为16。`HashTable`扩容时，容量变为原来的2倍加1，而`HashMap`扩容时，容量变为原来的2倍。

5. **初始容量和每次扩容的大小**：`HashMap`在创建时如果不指定容量的初始值，其默认的初始值大小为16，之后每次扩充，容量变为原来的2倍。而`HashTable`的默认初始值大小为11，之后每次扩充，容量变为原来的2n+1。

