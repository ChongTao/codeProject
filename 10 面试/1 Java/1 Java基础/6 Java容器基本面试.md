# 1 JAVA集合继承什么类

Java集合继承自多个类，但主要继承自两个接口：`Collection` 和 `Map`。

- `Collection` 接口是所有集合的顶层父接口，该集合中的方法可以被所有的单列集合共享。它包含两种主要的子类型：`List` 和 `Set`。
  - `List` 接口表示有序集合，其中的元素可以重复，且元素有索引，存取有序。常见的实现类有 `ArrayList` 和 `LinkedList`。
  - `Set` 接口表示无序集合，其中的元素唯一，不可重复。常见的实现类有 `HashSet`、`LinkedHashSet` 和 `TreeSet`。
- `Map` 接口表示键值对集合，其中保存的是键和值对。常见的实现类有 `HashMap` 和 `TreeMap`。

# 2 介绍一下List, Set, Queue, Map

List、Set、Queue和Map都是Java中的接口，用于处理不同种类的数据集合，它们之间的主要区别如下：

1. List（列表）：
   - 存储的元素是有序的，可以重复。
   - 元素在列表中的位置可以通过索引访问，类似于数组。
   - 常见的实现类有ArrayList和LinkedList，其中ArrayList提供了快速随机访问的能力，而LinkedList更擅长插入和删除操作。
2. Set（集合）：
   - 存储的元素是无序的，不可重复。
   - 不支持索引访问，通常通过迭代器遍历其元素。
   - 常见的实现类有HashSet和TreeSet，其中HashSet基于哈希表提供高效的查找、插入和删除操作，而TreeSet则保持了内部排序，可以进行顺序遍历或根据指定比较器进行排序。
3. Queue（队列）：
   - 遵循先进先出（FIFO）原则，存储的元素是有序的，可以重复。
   - 除了基本的FIFO特性外，还有其他类型的队列，如优先队列（PriorityQueue），其中元素按照自然顺序或自定义比较器提供的顺序进行排序。
   - 常见的实现类有LinkedList、ArrayDeque和PriorityQueue等。
4. Map（映射）：
   - 使用键值对（key-value）存储，其中key是无序的、不可重复的，value是无序的、可以重复的。
   - 每个键最多映射到一个值。
   - 不支持索引访问，但可以通过键来获取相应的值。
   - 常见的实现类有HashMap、TreeMap和LinkedHashMap等，其中HashMap提供常数时间复杂度的平均查找性能，TreeMap基于红黑树实现了键的排序，而LinkedHashMap在HashMap的基础上还维护了元素插入顺序。


# 3 ArrayList 可以添加 null 值吗

`ArrayList` 在 Java 中可以添加 `null` 值。`ArrayList` 是一个对象列表，可以存储任何类型的对象，包括 `null`。实际上，`ArrayList` 的内部实现就是一个动态数组，它使用一个 `Object[]` 数组来存储元素，而这个数组是可以包含 `null` 值的。

# 4 ArrayList 插入和删除元素的时间复杂度

`ArrayList` 在 Java 中插入和删除元素的时间复杂度取决于操作的具体位置和类型。

1. **在末尾插入或添加元素**：
   - 时间复杂度：O(1)
   - 说明：`ArrayList` 有一个内部数组，当在末尾添加元素时，通常只需要更新一个指向新大小的变量，并将新元素放在数组的最后一个位置。因此，这个操作的时间复杂度是常数时间。
2. **在开头插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：当在 `ArrayList` 的开头插入或删除元素时，所有现有的元素都需要移动一位。这是因为内部数组需要复制所有元素来保持连续性。因此，这个操作的时间复杂度是线性的，其中 n 是 `ArrayList` 的大小。
3. **在中间插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：在 `ArrayList` 的中间位置插入或删除元素也需要移动元素来保持连续性。具体来说，插入元素时，所有从插入点到数组末尾的元素都需要后移一位；删除元素时，所有从删除点到数组末尾的元素都需要前移一位。因此，这个操作的时间复杂度也是线性的。

# 5 ArrayList 和 Array的区别

ArrayList和数组（Array）在Java中都是用来存储数据的集合，但它们之间存在一些重要的区别：

1. **动态与静态**：ArrayList是动态数组，它的大小可以在运行时改变。这意味着当您需要添加或删除元素时，ArrayList会自动调整其大小。相反，数组是静态的，一旦创建，其大小就不能改变。如果您需要在数组中添加更多元素，您必须创建一个新的、更大的数组，然后将旧数组的内容复制到新数组中。
2. **数据类型**：ArrayList是一个对象列表，可以存储任何类型的对象，包括基本类型和对象类型。在存储基本类型时，ArrayList会自动进行装箱和拆箱操作。另一方面，数组可以存储基本类型和对象类型，但数组的元素类型必须一致。例如，如果定义了一个整数类型的数组，那么该数组中只能存储整数。
3. **功能**：ArrayList提供了更多的方法和特性，如addAll()、removeAll()和iterator()等，使得操作更为方便。而数组没有提供这些功能，其功能相对较为简单。
4. **内存管理**：ArrayList在存储时会检查空间大小，当空间不足时，会自动扩充为原来的1.5倍。这使得ArrayList在内存管理上更为灵活。而数组的空间大小是固定的，如果空间不足，需要手动创建新的数组并复制旧数组的内容。
5. **多维性**：数组可以支持一维、二维和多维，而ArrayList只相当于一维数组，不支持多维数组。

# 6 LinkedList 插入和删除元素的时间复杂度

`LinkedList` 在 Java 中插入和删除元素的时间复杂度取决于操作的位置。

1. **在开头或末尾插入或删除元素**：
   - 时间复杂度：O(1)
   - 说明：`LinkedList` 使用双向链表来存储元素。在链表的开头或末尾添加或删除元素只需要更新几个指针，不需要移动其他元素。因此，这些操作的时间复杂度是常数时间。
2. **在中间插入或删除元素**：
   - 时间复杂度：O(n)
   - 说明：当在链表的中间位置插入或删除元素时，需要遍历链表直到找到要插入或删除的位置。这个遍历过程的时间复杂度是线性的，因为它依赖于链表中要到达的节点的位置。一旦找到位置，插入或删除操作本身的时间复杂度是 O(1)，因为它只涉及更新几个指针。

# 7 ArrayList和LinkedList区别

ArrayList和LinkedList是Java中List接口的两种不同实现，主要区别如下：

## 7. 1 底层数据结构

- ArrayList：基于动态数组实现，内存连续，支持快速随机访问。
- LinkedList：基于双向链表实现，元素通过节点连接，内存分散，每个节点存储前后节点的引用。

## 7.2 时间复杂度对比

| **操作**                | **ArrayList**      | **LinkedList**       |
| :---------------------- | :----------------- | :------------------- |
| **随机访问（get/set）** | O(1)               | O(n)（需遍历链表）   |
| **头部插入/删除**       | O(n)（需移动元素） | O(1)                 |
| **尾部插入/删除**       | O(1)（均摊时间）   | O(1)                 |
| **中间插入/删除**       | O(n)（需移动元素） | O(n)（需遍历到位置） |

- **ArrayList**的插入/删除效率取决于位置：尾部操作高效，中间或头部需要移动元素。
- **LinkedList**的插入/删除在已知位置时高效（仅修改指针），但需遍历到位置的耗时可能抵消其优势。

## 7.3 内存占用

- ArrayList：仅存储数据，内存连续，可能有预留空间（动态扩容时）。
- LinkedList：每个节点额外存储前后指针，占用更多内存。频繁增删可能产生内存碎片。

## 7.4 遍历性能

- **ArrayList**：通过索引（如`for`循环）遍历效率高（O(1)随机访问）。
- **LinkedList**：应使用迭代器遍历（O(n)），避免通过索引遍历（性能极差）。

## 7.5 应用场景

- ArrayList更适合频繁随机访问, 尾部插入/删除操作，内存敏感的场景（占用更少）。
- LinkedList更适合频繁在头部或中间插入/删除（如实现队列、栈），不需要大量随机访问的场景。

## 7.6 其他区别

- **扩容机制**：ArrayList需动态扩容（默认扩容50%），可能导致数组复制；LinkedList无需扩容。
- **功能扩展**：LinkedList实现了Deque接口，可直接用作双端队列或栈；ArrayList无此特性。
- **缓存友好性**：ArrayList内存连续，缓存命中率高；链表节点分散，缓存不友好。

# 8 HashSet 如何检查重复

`HashSet` 是 Java 中的一个类，它实现了 `Set` 接口，用于存储不重复的元素。`HashSet` 内部使用一个 `HashMap` 来存储元素，其中元素作为键（Key），而值（Value）通常是一个常量（例如 `PRESENT`）。由于 `HashMap` 的键是唯一的，因此 `HashSet` 能够确保存储的元素也是唯一的。

当你尝试向 `HashSet` 中添加一个元素时，`HashSet` 会使用元素的 `hashCode()` 方法来计算该元素的哈希码，并基于这个哈希码来确定元素在 `HashMap` 中的存储位置。然后，`HashSet` 会检查该位置是否已经有元素存在。如果存在，它会使用 `equals()` 方法来比较新元素与已存在元素是否相等。如果相等，则新元素不会被添加到 `HashSet` 中，因为 `HashSet` 不允许重复元素。如果不相等，那么新元素会替换已存在的元素，因为 `HashMap` 的键是唯一的。

因此，`HashSet` 检查重复的方式是基于元素的 `hashCode()` 和 `equals()` 方法。首先，它使用 `hashCode()` 方法来确定元素在 `HashMap` 中的存储位置。然后，它使用 `equals()` 方法来比较新元素与已存在元素是否相等。如果两个方法都返回相同的结果，那么 `HashSet` 就认为这两个元素是重复的。

# 9 HashTable和HashMap区别

`HashTable`和`HashMap`都是Java中用于存储键值对的集合类，但它们之间存在一些重要的区别：

1. **线程安全性**：`Hashtable`是线程安全的，因为它的大多数方法都是同步的，可以在多线程环境中安全使用。而`HashMap`是非线程安全的，它的方法不是同步的，因此在多线程环境中使用时需要额外的同步措施。

2. **效率**：由于`Hashtable`是线程安全的，其性能通常比非线程安全的`HashMap`低。因为同步操作会带来额外的开销。然而，如果你的应用程序是单线程的，或者你可以通过其他方式（如使用`Collections.synchronizedMap()`方法）来同步`HashMap`，那么`HashMap`的性能可能会更高。

3. **对null的支持**：`HashMap`允许使用`null`作为键（key）和值（value），但键只能有一个`null`，而可以有多个键所对应的值为`null`。相比之下，`Hashtable`不允许使用`null`作为键或值。

4. **扩容方式**：在不指定容量的情况下，`HashTable`的默认容量为11，而`HashMap`的默认容量为16。`HashTable`扩容时，容量变为原来的2倍加1，而`HashMap`扩容时，容量变为原来的2倍。

5. **初始容量和每次扩容的大小**：`HashMap`在创建时如果不指定容量的初始值，其默认的初始值大小为16，之后每次扩充，容量变为原来的2倍。而`HashTable`的默认初始值大小为11，之后每次扩充，容量变为原来的2n+1。

# 10 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

HashSet、LinkedHashSet和TreeSet都是Java集合框架中的类，用于存储不重复的元素，并且都实现了Set接口。以下是它们之间的异同点：

1. **底层数据结构**：
   - **HashSet**：基于哈希表实现。它不保证元素的顺序，并且允许一个null元素。
   - **LinkedHashSet**：是HashSet的子类，使用链表来维护元素的插入顺序。因此，它按照元素插入的顺序进行迭代，并且同样允许一个null元素。
   - **TreeSet**：基于红黑树（一种自平衡二叉查找树）实现。它会对元素进行排序，并且不允许null元素。
2. **性能**：
   - 在大多数情况下，**HashSet**的性能最好，因为其基于哈希表的实现允许O(1)时间复杂度的添加和删除操作。
   - **LinkedHashSet**的性能与HashSet相似，因为它也使用哈希表，并且插入和删除操作也是O(1)时间复杂度。
   - **TreeSet**的性能通常较差，因为它需要对元素进行排序，其添加和删除操作的时间复杂度为O(log n)。

3. **元素排序**：
   - **HashSet**不保证元素的顺序。
   - **LinkedHashSet**保证元素按照插入的顺序进行排序。
   - **TreeSet**保证元素处于排序状态，支持自然排序和自定义排序规则。
  
4. **null值**：
   - **HashSet**和**LinkedHashSet**都允许存储一个null元素。
   - **TreeSet**不允许存储null元素，如果尝试添加null元素，会抛出`java.lang.NullPointerException`异常。

# 11 Queue 与 Deque 的区别

Queue和Deque都是Java中的接口，它们都继承自Collection接口，但Deque是Queue的子接口。它们的主要区别在于支持的操作和使用的场景。

1. 操作支持：
   - Queue（队列）：Queue是一种先进先出（FIFO）的数据结构，只支持在队列的尾部添加元素（enqueue），以及在队列的头部移除元素（dequeue）。因此，Queue的操作是单向的。
   - Deque（双端队列）：Deque则支持在队列的两端进行添加和移除元素的操作。也就是说，Deque既可以在队尾添加或移除元素，也可以在队首添加或移除元素。这使得Deque的操作更加灵活。
2. 使用场景：
   - Queue：由于Queue只支持在队尾添加元素和在队首移除元素，因此它常被用于实现任务队列、消息队列等场景。在这些场景中，元素按照它们被添加的顺序进行处理。
   - Deque：由于Deque支持在两端进行添加和移除元素的操作，因此它常被用于实现栈（先进后出）、队列（先进先出）等数据结构。此外，Deque还可以用于实现一些需要频繁在两端进行操作的算法，如LRU缓存等。

# 12 ConcurrentHashMap 和 Hashtable 的区别

ConcurrentHashMap和Hashtable在Java中都是用于存储键值对的Map接口实现类，但它们在实现线程安全、性能、以及底层数据结构等方面存在一些主要区别：

1. **线程安全实现方式**：ConcurrentHashMap和Hashtable都是线程安全的，但它们的实现方式不同。ConcurrentHashMap使用了一种称为分段锁的技术，将整个桶数组分为多个段，每个锁只锁容器中的一部分数据。这种设计使得多线程访问容器中不同数据段的数据时，不会存在锁竞争，从而提高了并发访问率。而Hashtable则使用传统的synchronized来保证线程安全，当一个线程访问同步方法时，其他线程可能进入阻塞或轮询状态，导致效率降低。
2. **性能**：由于ConcurrentHashMap采用了分段锁的设计，使得它在多线程环境下的性能通常优于Hashtable。Hashtable在每次同步访问时都需要获取整个容器的锁，这可能导致线程阻塞和性能下降。而ConcurrentHashMap通过将锁细化到桶级别，减少了锁竞争，从而提高了性能。
3. **底层数据结构**：在JDK 1.8及之后的版本中，ConcurrentHashMap的底层数据结构采用了数组+链表+红黑树的形式，当链表长度达到一定阈值时，会将其转换为红黑树以提高搜索性能。而Hashtable的底层数据结构也是数组+链表的形式，但它在JDK 1.8之前的版本中就已经被废弃，因此在现代Java应用中较少使用。
