# 1 介绍一下Java的泛型

泛型（Generics） 是Java 5引入的特性，允许在定义类、接口或方法时使用类型参数，从而将类型检查从运行时提前到编译时，提高代码的安全性和重用性。泛型的核心思想是参数化类型，即让代码操作的数据类型不固定，而是通过具体使用场景指定。

```java
// 泛型类
class Box<T> {
    private T content;
    public void setContent(T content) { 
        this.content = content; 
    }
    public T getContent() { return content; }
}

// 使用时指定具体类型
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello");
String value = stringBox.getContent(); // 无需强制转换
```

- 类型安全：编译器检查类型合法性，避免运行时ClassCastException。
- 消除强制转换：直接使用正确类型，代码更简洁。
- 代码复用：一套逻辑可适配多种类型，减少重复代码。

# 2 介绍一下泛型的使用场景

## 2.1 泛型的使用

1. **泛型类**：这是最常见的泛型使用方式。你可以定义一个类，并在类名后面添加类型参数。例如，`ArrayList<E>`就是一个泛型类，其中`E`是一个类型参数，代表该ArrayList可以存储的元素的类型。
2. **泛型接口**：与泛型类类似，你也可以定义泛型接口。泛型接口中定义的方法可以引用类型参数。
3. **泛型方法**：这是Java 5引入的新特性。你可以在方法签名中定义类型参数，这样，方法就可以处理不同类型的参数并返回相应类型的结果。泛型方法的一个关键特点是，类型参数只能代表方法中的返回类型或局部变量的类型，不能代表类中的成员变量的类型。
4. **泛型限制**：通过通配符（`?`）和边界（如`? extends Number`或`? super Integer`）来进一步控制泛型的使用。

## 2.2 泛型的好处

1. **类型安全**：通过泛型，编译器能够在编译时检查类型，避免了运行时类型转换错误。
2. **代码重用**：泛型允许你编写更加通用的代码，提高了代码的重用性。
3. **减少强制类型转换**：使用泛型后，编译器会自动处理类型转换，减少了程序员手动进行类型转换的工作量。

# 3 类型通配符

在Java泛型中，类型通配符（Type Wildcards）是一种表示未知类型的方式。它们允许你在编写泛型代码时更加灵活，因为你不需要在编译时知道具体的类型。类型通配符使用`?`来表示。类型通配符主要有三种形式：

1. **无界通配符（Unbounded Wildcard）**：这是最简单的通配符形式，它表示任何类型。当你使用`?`时，你就创建了一个无界通配符。例如，`List<?>`表示一个列表，其中可以包含任何类型的对象。

```java
List<?> wildcardList = getSomeList(); // getSomeList() 返回一个List，但具体类型未知
```

2. **上界通配符（Upper Bounded Wildcard）**：这种形式的通配符使用`extends`关键字来指定类型的上界。它表示参数化类型或该类型的任何子类型。例如，`List<? extends Number>`表示一个列表，其中可以包含`Number`类型或其任何子类型（如`Integer`, `Double`等）的对象。

```java
List<? extends Number> upperBoundedList = getSomeNumberList(); // 返回Number或其子类型的列表
```

3. **下界通配符（Lower Bounded Wildcard）**：这种形式的通配符使用`super`关键字来指定类型的下界。它表示参数化类型或该类型的任何超类型。然而，在Java的泛型系统中，下界通配符的使用相对较少，因为通常不需要对泛型参数设置下限。

```java
List<? super Integer> lowerBoundedList = getSomeList(); // 返回Integer或其超类型的列表
```

# 3 类型擦除

Java泛型在编译时采用了一种称为类型擦除（Type Erasure）的技术。类型擦除是Java泛型实现的一个关键机制，它确保了与旧版本Java代码的兼容性，并且在运行时不会带来额外的性能开销。

类型擦除的主要概念是，在编译时，Java泛型信息会被擦除，并且在生成的字节码中，泛型类型信息会被替换为原始类型（raw types）或`Object`类型。这意味着运行时环境并不知道泛型类型的具体信息。

1. **类型参数的擦除**：泛型类型参数在编译时被擦除，并被替换为具体的类型（如果有的话）或`Object`类型。例如，`List<String>`在类型擦除后将被视为`List`。
2. **桥接方法的生成**：为了确保类型安全，编译器会生成额外的桥接方法（bridge methods）来确保父类引用能够调用子类中的泛型方法。这是因为在Java中，方法的签名包括方法名和参数类型，而泛型类型在运行时是不可见的，所以需要桥接方法来保持多态性。
3. **泛型约束的校验**：虽然泛型类型信息在运行时不可用，但编译器会在编译时检查泛型约束（如`extends`和`super`）。如果违反了约束，编译器将发出错误。
4. **泛型类型的替换**：在某些情况下，泛型类型参数可能会被具体的类型替换。例如，当泛型类型参数被用作数组的类型时，它将被替换为`Object[]`。

由于类型擦除的存在，Java泛型在运行时并不保留泛型类型信息。这意味着你不能在运行时询问一个对象是否是特定泛型类型的实例，因为所有泛型类型信息都已在编译时被擦除。
