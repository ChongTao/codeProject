# 1 HashMap数据结构和实现原理

## 1.1 HashMap的数据结构

HashMap底层实现数据结构为数组+链表的形式，JDK8及其以后的版本中使用了数组+链表+红黑树实现，解决了链表太长导致的查询速度变慢的问题。
简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。HashMap通过key的HashCode经过扰动函数处理过后得到Hash值，然后通过位运算判断当前元素存放的位置，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。当Map中的元素总数超过Entry数组的0.75时，触发扩容操作，为了减少链表长度，元素分配更均匀。

## 1.2 为什么这里把key的hashcode取出来，然后把它右移16位，然后取异或？

因为int是4个字节，也就是32位，大概是有40亿的空间，如果哈希函数运用的比较松散，一般是很难出现哈希碰撞的。但是现实中一个长度为40亿的数组内存是放不下的并且HashMap在扩容前的数组的默认初始值为16，因此直接拿Hashcode值来用是不现实的。因此需要做一些运算。我们右移16位也即是把高位的数据右移到低位的16位，然后与自己做异或，那就是把高位和低位的数据进行混合，以此来加大低位的随机性，同时混合后的低位掺杂了高位的特征，这样高位的信息也被变相保存了下来。这么做主要是从速度，功效和质量来考虑的。

## 1.3 默认初始化大小是多少？为啥是这么多？为啥大小都是2的幂？

hash运算的过程其实就是对目标元素的Key进行hashcode，再对Map的容量进行取模，而JDK 的工程师为了提升取模的效率，使用位运算代替了取模运算，这就要求Map的容量一定得是2的幂。
HashMap的容量为什么是2的n次幂，和这个（n - 1) & hash的计算方法有着千丝万缕的关系，符号&是按位与的计算，这是位运算，计算机能直接运算，特别高效，按位与&的计算方法是，只有当对应位置的数据都为1时，运算结果也为1，当HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够（充分的散列），使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。

## 1.4 哈希冲突及解决方法

 如果两个不同对象的hashCode相同，这种现象称为hash冲突。有以下的方式可以解决哈希冲突：

1. 开放定址法：开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
2. 链地址法链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
3. 再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
4. 建立公共溢出区 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

## 1.5 扩容条件

HashMap有两种情况下会触发扩容：

1. 元素数量超过阈值（Threshold）

> 阈值 = 当前容量（Capacity）× 负载因子（Load Factor）。
> 默认容量：16（首次插入时初始化），默认负载因子：0.75。当元素数量超过容量 × 0.75 时，触发扩容。

2. 链表转红黑树时容量不足
当链表长度 ≥ 8，且当前数组长度 < 64 时，优先扩容（而不是树化）。这是为了避免链表过长导致查询效率下降。

## 1.6 扩容的规则

1. 容量翻倍：新容量 = 旧容量 × 2（始终保持 2 的幂次方，如 16 → 32 → 64）。

2. 重新计算哈希
   - 所有元素会通过 rehash 重新分配到新数组的桶中。
   - Java 8 优化：利用高位哈希值判断元素在新数组中的位置（无需重新计算哈

# 2 HashMap 为什么线程不安全？

HashMap 在 Java 中是线程不安全的，主要原因在于其底层实现未对多线程环境做同步处理，可能导致以下问题：

## 1.1 多线程插入导致数据覆盖

当多个线程同时调用 put() 方法时，可能会覆盖彼此的数据, 例如两个线程同时尝试插入不同的键值对，且它们的键计算出的哈希值相同（哈希碰撞）。原因：在插入链表或红黑树时，若线程未同步，可能导致：

- 链表节点丢失：一个线程的 next 指针被另一个线程覆盖。
- 数据不一致：最终只有一个线程的键值对被保留。

```java
map.put(key1, value1);
map.put(key2, value2);
```

## 1.2 扩容时可能引发死循环（JDK 1.7 及之前）

在 JDK 1.7 中，HashMap 使用头插法转移链表节点，多线程扩容时可能形成环形链表，例如线程 A 和线程 B 同时触发扩容，线程 A 在转移链表时被挂起，线程 B 完成转移并形成环形链表。后续调用 get() 方法访问该链表时，导致无限循环（CPU 100%）。

JDK 1.8 改进：改用尾插法，避免了环形链表问题，但扩容时仍可能数据错乱。

## 1.3 迭代时并发修改导致异常

快速失败（Fail-Fast）：当线程迭代 HashMap（如通过 Iterator）时，若另一个线程修改了结构（增/删节点），会抛出 `ConcurrentModificationException`。原因：迭代器依赖 modCount 字段记录修改次数，若发现与其他线程修改冲突，立即失败。

## 1.4 并发更新导致值覆盖

即使哈希未冲突，多个线程同时修改同一个键的值，也可能导致最终结果不符合预期：

## 1.5 解决方案

使用线程安全的Map，例如使用`ConcurrentHashMap`，或者`Collections.synchronizedMap()`

# 3 HashMap什么情况用到红黑树

在 Java 的 HashMap 中，红黑树的引入是为了优化**哈希冲突**严重时的查询性能。

## 3.1 触发红黑树转换的条件

当 HashMap 的某个哈希桶（Bucket）中的链表长度 超过阈值 8，并且当前 HashMap 的数组容量达到或超过 64 时，该链表会被转换为红黑树。如果数组容量不足 64，即使链表长度超过 8，HashMap 也会优先选择扩容数组（而不是树化），因为扩容可以更直接地减少哈希冲突。

```java
// Java 8 HashMap 的树化逻辑源码片段
if (binCount >= TREEIFY_THRESHOLD - 1) { 
    // TREEIFY_THRESHOLD = 8
    treeifyBin(tab, hash);
}

final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY) { 
        // MIN_TREEIFY_CAPACITY = 64
        resize(); // 优先扩容数组
    } else {
        // 转换为红黑树
    }
}
```

## 3.2 退化为链表的条件

当红黑树中的节点数量减少到6或更少时，红黑树会退化为链表。
这是为了避免树结构在小规模数据下的维护开销（例如频繁的插入、删除操作可能触发树的再平衡）。

## 3.3 为什么选择红黑树

- 性能平衡：红黑树的查询时间复杂度为 O(log n)，远优于链表的 O(n)，但插入/删除效率略低于链表。
- 防止哈希碰撞攻击：如果恶意构造大量哈希冲突的键，链表的性能会急剧下降（复杂度 O(n)），而红黑树能保证最坏情况下仍为 O(log n)。
- 自平衡特性：红黑树通过颜色标记和旋转规则，确保树的高度大致平衡，避免退化为链表。

# 4 HashMap 的哈希/扰动函数设计详解

在 Java 的 HashMap 中，哈希函数（Hash Function） 和 扰动函数（Perturbation Function） 的设计是确保键值对均匀分布到数组（桶）中的核心机制。其目的是通过优化哈希值的分布，减少哈希冲突，从而提高查询效率。

## 4.1 目标

- 减少哈希冲突：避免不同的键映射到同一个桶（数组位置）。
- 高效计算：在保证分布均匀的前提下，尽量降低计算开销。
- 适应动态扩容：哈希值需在数组扩容（如翻倍）时，依然能均匀分布。

## 4.2 设计步骤

1. 扰动原始哈希值
直接使用键的 hashCode() 可能存在问题，若 hashCode() 的高位变化大但低位重复多（例如连续的数值键），会导致大量冲突。若 hashCode() 质量差（如某些自定义类未正确覆写），哈希分布不均匀。

2. 扰动函数的作用
将原始哈希码的高位特征与低位混合，增加低位的随机性，减少冲突。

通过将哈希码的高 16 位与低 16 位进行异或（XOR），确保高位的变化能影响低位结果：

```java
static final int hash(Object key) {
    int h;
    // key.hashCode() ^ (h >>> 16)
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

# 5 当new HashMap将会发生什么

在 Java 中，当你使用 new HashMap<>() 创建一个 HashMap 实例时，底层会经历以下过程：

1. 构造函数调用

- 默认构造函数：new HashMap<>() 会调用无参构造函数。
- 参数初始化：
  - 初始容量（Initial Capacity）：默认值为 16。
  - 负载因子（Load Factor）：默认值为 0.75。

2. 初始容量的计算

- 容量调整为 2 的幂次方：HashMap 的容量始终是 2 的幂次方（如 16, 32, 64）。
即使你手动指定一个初始容量（如 new HashMap<>(10)），实际容量会被调整为 16（即大于等于该值的最小 2 的幂次方）。
- 调整方法：通过 tableSizeFor() 方法计算。

3. 阈值（Threshold）的初始化

- 阈值 = 容量 × 负载因子：
在构造函数中，阈值（threshold）会被暂时设置为 capacity * loadFactor。但此时底层数组（Node<K,V>[] table）尚未分配内存（懒加载机制）。

4. 数组的懒加载（Lazy Initialization）

- 首次插入数据时初始化数组：
在第一次调用 put() 方法时，才会真正创建底层数组 table。

# 10 红黑树怎么保持平衡的

红黑树通过一系列的操作来保持平衡，这些操作包括旋转和染色。红黑树的每个节点都有两种颜色：红色或黑色，并且遵循一系列规则来确保树的平衡。以下是红黑树保持平衡的关键点：

1. **节点颜色规则**：

   - 每个节点要么是红色，要么是黑色。
   - 根节点总是黑色的。
   - 如果一个节点是红色的，那么它的两个子节点必须是黑色的（但反过来不一定成立，即黑色节点的子节点可以是红色或黑色）。
   - 从任一节点到其每个叶子的所有路径都包含相同数量的黑色节点。

2. **旋转操作**：

   - 红黑树在插入或删除节点时，可能会违反上述规则。为了重新平衡树，红黑树会执行旋转操作。
   - 旋转有两种类型：左旋和右旋。旋转的目的是通过调整节点和它们的子节点之间的关系来改变树的形状，同时保持树的基本性质（即每个节点都有一个左子节点和一个右子节点，并且左子节点的值小于父节点，右子节点的值大于或等于父节点）。
   - 在插入操作中，如果父节点和叔叔节点都是红色，或者如果新插入的节点导致其父节点成为红色并且父节点的父节点（即祖父节点）也是红色，那么就需要进行旋转操作。

3. **染色操作**：

   在某些情况下，红黑树可能需要通过改变节点的颜色来保持平衡。例如，在插入操作中，如果新插入的节点导致其父节点成为红色并且父节点的父节点（即祖父节点）也是红色，那么可能需要进行染色操作。这通常涉及将祖父节点或父节点从红色更改为黑色，并将叔叔节点（如果存在）从黑色更改为红色。
   
   红黑树通过这些操作确保了树的高度始终保持在O(log N)的范围内，其中N是树中节点的数量。这使得红黑树在插入、删除和查找操作中都能保持较高的效率。



# 红黑树转回链表的阈值为什么是6，而不是8





## 为什么HashMap链表转红黑树的阈值为8





## 为什么哈希/扰动函数能降hash碰撞



## hashmap为什么用红黑树不用二叉树或者平衡二叉树



## 初始化HashMap，传一个17的值会怎么处理





## 扩容是耗时的，能不能把负载因子调高一点