# 1 HashMap 为什么线程不安全？

HashMap 在 Java 中是线程不安全的，主要原因在于其底层实现未对多线程环境做同步处理，可能导致以下问题：

## 1.1 多线程插入导致数据覆盖

当多个线程同时调用 put() 方法时，可能会覆盖彼此的数据, 例如两个线程同时尝试插入不同的键值对，且它们的键计算出的哈希值相同（哈希碰撞）。原因：在插入链表或红黑树时，若线程未同步，可能导致：

- 链表节点丢失：一个线程的 next 指针被另一个线程覆盖。
- 数据不一致：最终只有一个线程的键值对被保留。

```java
map.put(key1, value1);
map.put(key2, value2);
```

## 1.2 扩容时可能引发死循环（JDK 1.7 及之前）

在 JDK 1.7 中，HashMap 使用头插法转移链表节点，多线程扩容时可能形成环形链表，例如线程 A 和线程 B 同时触发扩容，线程 A 在转移链表时被挂起，线程 B 完成转移并形成环形链表。后续调用 get() 方法访问该链表时，导致无限循环（CPU 100%）。

JDK 1.8 改进：改用尾插法，避免了环形链表问题，但扩容时仍可能数据错乱。

## 1.3 迭代时并发修改导致异常

快速失败（Fail-Fast）：当线程迭代 HashMap（如通过 Iterator）时，若另一个线程修改了结构（增/删节点），会抛出 `ConcurrentModificationException`。原因：迭代器依赖 modCount 字段记录修改次数，若发现与其他线程修改冲突，立即失败。

## 1.4 并发更新导致值覆盖

即使哈希未冲突，多个线程同时修改同一个键的值，也可能导致最终结果不符合预期：

## 1.5 解决方案

使用线程安全的Map，例如使用ConcurrentHashMap，或者Collections.synchronizedMap()：

ConcurrentHashMap。Hashtable 通过在每个方法上添加同步来实现线程安全，但效率较低。而 Concurr是线程不安全的，主要原因在于其实现方式涉及多个可以并发修改的操作，而这些操作没有被同步，导致在并发环境下可能会产生数据不一致的问题。具体来说，HashMapentHashMap 则采用了一种更细粒度的锁策略，以提高并发性能。

# 2 HashMap什么情况用到红黑树

在 Java 的 HashMap 中，红黑树的引入是为了优化**哈希冲突**严重时的查询性能。

## 2.1 触发红黑树转换的条件

当 HashMap 的某个哈希桶（Bucket）中的链表长度 超过阈值 8，并且当前 HashMap 的数组容量 达到或超过 64 时，该链表会被转换为红黑树。如果数组容量不足 64，即使链表长度超过 8，HashMap 也会优先选择扩容数组（而不是树化），因为扩容可以更直接地减少哈希冲突。

```java
// Java 8 HashMap 的树化逻辑源码片段
if (binCount >= TREEIFY_THRESHOLD - 1) { 
    // TREEIFY_THRESHOLD = 8
    treeifyBin(tab, hash);
}

final void treeifyBin(Node<K,V>[] tab, int hash) {
    int n;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY) { 
        // MIN_TREEIFY_CAPACITY = 64
        resize(); // 优先扩容数组
    } else {
        // 转换为红黑树
    }
}
```

## 2.2 退化为链表的条件

当红黑树中的节点数量减少到6或更少时，红黑树会退化为链表。
这是为了避免树结构在小规模数据下的维护开销（例如频繁的插入、删除操作可能触发树的再平衡）。

## 2.3 为什么选择红黑树

- 性能平衡：红黑树的查询时间复杂度为 O(log n)，远优于链表的 O(n)，但插入/删除效率略低于链表。
- 防止哈希碰撞攻击：如果恶意构造大量哈希冲突的键，链表的性能会急剧下降（复杂度 O(n)），而红黑树能保证最坏情况下仍为 O(log n)。
- 自平衡特性：红黑树通过颜色标记和旋转规则，确保树的高度大致平衡，避免退化为链表。

# 3 HashMap 的哈希/扰动函数设计详解

在 Java 的 HashMap 中，哈希函数（Hash Function） 和 扰动函数（Perturbation Function） 的设计是确保键值对均匀分布到数组（桶）中的核心机制。其目的是通过优化哈希值的分布，减少哈希冲突，从而提高查询效率。

## 3.1 目标

- 减少哈希冲突：避免不同的键映射到同一个桶（数组位置）。
- 高效计算：在保证分布均匀的前提下，尽量降低计算开销。
- 适应动态扩容：哈希值需在数组扩容（如翻倍）时，依然能均匀分布。

## 3.2 设计步骤

1. 扰动原始哈希值
直接使用键的 hashCode() 可能存在问题，若 hashCode() 的高位变化大但低位重复多（例如连续的数值键），会导致大量冲突。若 hashCode() 质量差（如某些自定义类未正确覆写），哈希分布不均匀。

2. 扰动函数的作用
将原始哈希码的高位特征与低位混合，增加低位的随机性，减少冲突。

通过将哈希码的高 16 位与低 16 位进行异或（XOR），确保高位的变化能影响低位结果：

```java
static final int hash(Object key) {
    int h;
    // key.hashCode() ^ (h >>> 16)
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
