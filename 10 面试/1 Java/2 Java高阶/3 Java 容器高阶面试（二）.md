# 1 介绍 ArrayList 的扩容机制

ArrayList的扩容机制是其在内部实现动态数组时的一个关键特性。当ArrayList中的元素数量超过了其当前容量时，它会自动扩容以容纳更多的元素。这个扩容过程是通过创建一个新的、更大的数组，并将旧数组中的元素复制到新数组中来完成的。

1. **判断是否需要扩容**：当向ArrayList添加元素时，首先会检查当前元素数量是否已经达到了数组的最大容量。如果达到了最大容量，就需要进行扩容。
2. **计算新的容量**：ArrayList的扩容大小通常是当前容量的1.5倍（即`newCapacity = oldCapacity + (oldCapacity >> 1)`）。这是通过右移操作实现的，相当于将当前容量除以2后再加上原容量。然而，有一个上限值，当ArrayList的大小超过`Integer.MAX_VALUE - 8`时，扩容就不再是1.5倍了，而是直接增加到`Integer.MAX_VALUE`。
3. **创建新数组**：根据计算出的新容量，创建一个新的数组。新数组的大小等于计算出的新容量。
4. **元素复制**：将旧数组中的所有元素复制到新数组中。这个过程是从数组的第一个元素开始，逐个复制到新数组的对应位置，直到所有元素都被复制完毕。
5. **更新引用**：将ArrayList内部对数组的引用更新为新创建的数组，这样后续添加的元素就会存储在新数组中。

# 2 介绍 LinkHashMap 原理

`LinkedHashMap` 是 Java 集合框架中的一个类，它是 `HashMap`的一个子类，并且在`HashMap`的基础上维护了一个双向链表来保持元素的插入顺序或者访问顺序。

1. **基于 HashMap**：LinkedHashMap 的底层仍然是基于 HashMap 来实现键值对的存储。HashMap 使用数组和链表（或者红黑树）来存储元素，其中数组用于存储键和值，而链表（或红黑树）用于处理哈希冲突。
2. **双向链表**：LinkedHashMap 在 HashMap 的基础上增加了一个双向链表，用于维护元素的顺序。这个双向链表保证了元素的迭代顺序与插入顺序或者访问顺序一致。每个节点（Entry）在链表中都包含了对前一个节点和后一个节点的引用。
3. **插入顺序和访问顺序**：LinkedHashMap 提供了两种顺序模式：插入顺序和访问顺序。在插入顺序模式下，元素的迭代顺序与它们被插入到映射中的顺序相同。在访问顺序模式下，元素的迭代顺序与它们最近被访问的顺序相同（访问顺序通过记录每次访问来更新链表）。
4. **性能特点**：由于 LinkedHashMap 的底层是 HashMap，因此它支持高效的查找、插入和删除操作，时间复杂度通常为 O(1)。同时，由于双向链表的存在，它还能够按照特定的顺序迭代元素，这使得它在需要保持元素顺序的场景下非常有用。
5. **线程安全**：与 HashMap 和 TreeMap 一样，LinkedHashMap 也不是线程安全的。如果在多线程环境中使用 LinkedHashMap，并且多个线程同时修改它，那么可能需要额外的同步措施来确保数据的完整性。

总之，LinkedHashMap 的底层原理是在 HashMap 的基础上增加了一个双向链表来维护元素的顺序。这使得它能够在保持元素顺序的同时提供高效的查找、插入和删除操作。然而，需要注意的是 LinkedHashMap 也不是线程安全的。