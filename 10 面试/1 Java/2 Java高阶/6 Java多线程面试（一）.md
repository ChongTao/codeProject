# 1 synchronized和volatile区别

`synchronized`和`volatile`是Java中两种常用的关键字，用于处理多线程环境下的并发问题，但它们之间存在一些关键的区别。

## 1.1 作用

- `volatile`关键字告诉Java虚拟机（JVM）当前变量在工作内存中的值是不确定的，需要从主内存中读取。它确保变量在每次被线程访问时都会从主内存中读取其值，而不是从线程的本地内存中读取。
- `synchronized`关键字则锁定当前变量，确保同一时刻只有一个线程可以访问该变量。当线程尝试进入被`synchronized`修饰的代码块或方法时，它需要获得一个锁。如果锁已被其他线程持有，则该线程将被阻塞，直到锁被释放。

## 1.2 作用范围

- `volatile`只能用于变量级别的修饰。
- `synchronized`可以用于变量、方法以及类级别的修饰，例如可以修饰一个方法或一个代码块，甚至可以用来修饰一个静态方法，表示该类的一个锁。
  
## 1.3 线程安全性

- `volatile`只能保证数据的可见性，但不能保证数据操作的原子性。也就是说，如果一个操作包含读取和修改变量，那么`volatile`不能确保这两个操作是作为一个不可分割的整体来执行的。
- `synchronized`不仅可以保证可见性，还可以保证原子性。它确保同一时刻只有一个线程可以执行被`synchronized`修饰的代码块或方法，从而防止多个线程同时修改共享数据，保证了线程安全。

## 1.4 性能开销

- `volatile`是一种轻量级的同步机制，因为它不会造成线程的阻塞，只是简单地从主内存中读取变量的值。
- `synchronized`是一种重量级的同步机制，因为它可能会导致线程阻塞，从而可能引入更高的性能开销。当多个线程争抢`synchronized`锁对象时，它们会进入阻塞状态，直到锁被释放。
  
## 1.5 编译器优化

- `volatile`标记的变量不会被编译器优化，以确保每次读取都是从主内存中读取。
- `synchronized`标记的变量可能会被编译器优化，以提高代码的执行效率。

总结来说，`volatile`和`synchronized`在Java中都是用于处理并发问题的关键字，但它们在作用机制、应用级别、线程安全性、性能开销以及编译器优化等方面存在显著的差异。在选择使用哪个关键字时，应根据具体的应用场景和需求来做出决策。

# 2 什么是线程死锁?如何避免死锁?

线程死锁是指两个或更多的线程在无限期地等待一个资源（例如锁），从而导致它们都无法继续执行。这通常发生在每个线程都持有一个资源，并请求获取另一个线程已持有的资源时，导致它们都在等待对方释放资源，从而形成了一个循环等待条件。

以下是四个可能导致死锁的必要条件，也被称为死锁的四个充分条件：

1. **互斥条件**：资源不能被共享，即一个资源一次只能被一个线程使用。
2. **持有并等待**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不可抢占**：资源不能被其他线程抢占，即资源只能由获得它的线程自己来释放。
4. **循环等待**：系统中若干个线程形成一种头尾相接的循环等待资源关系。

为了避免线程死锁，可以采取以下策略：

1. **避免一个线程同时获取多个锁**：如果可能，尽量让一个线程只获取一个锁。如果需要获取多个锁，考虑使用一次性获取所有锁的方法，而不是分步获取。
2. **避免在持有锁时等待获取其他锁**：如果一个线程已经持有一个锁，并需要获取另一个锁，考虑释放已持有的锁，然后再尝试获取所需的锁。
3. **尽量减少锁的持有时间**：一旦线程完成必要的操作并释放了锁，其他线程就可以立即获取该锁。
4. **设置锁的超时时间**：如果线程在获取锁时等待超时，则放弃获取锁，从而避免死锁。
5. **使用死锁检测工具**：例如 Java 的 `jstack` 工具，可以检测死锁线程的状态和调用栈信息，从而及时发现和解决死锁问题。
6. **使用避免死锁的算法和协议**：例如银行家算法等，这些算法和协议可以确保系统始终处于安全状态，从而避免死锁的发生。


