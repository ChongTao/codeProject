

# 1 BlockingQueue底层原理

`BlockingQueue` 是 Java 并发包 `java.util.concurrent` 中的一个接口，它表示一个由线程安全地访问的先进先出（FIFO）队列。这个队列被设计用来支持在并发编程中的线程同步。`BlockingQueue` 允许一个或多个线程等待队列变为非空（用于从队列中取出元素），或者允许一个或多个线程等待队列变为非满（用于向队列中插入元素）。这些等待操作会导致线程阻塞，直到其他线程执行相应的操作。

1. **ArrayBlockingQueue**： 一个由数组支持的有界阻塞队列。这个队列按照 FIFO（先进先出）的原则对元素进行排序。当队列为空时，获取元素的线程会被阻塞，直到有元素被放入队列；当队列已满时，尝试添加元素的线程会被阻塞，直到队列中有元素被取出。
2. **LinkedBlockingQueue**： 一个由链表支持的可选有界阻塞队列。如果创建时指定了容量，那么它就是一个有界队列；如果没有指定容量，那么它就是一个无界队列。与 `ArrayBlockingQueue` 类似，它也支持在队列为空时阻塞获取元素的线程，以及在队列满时阻塞添加元素的线程。
3. **PriorityBlockingQueue**： 一个支持优先级排序的无界阻塞队列。元素按照它们的自然排序或者通过提供的 `Comparator` 进行排序。当队列为空时，获取元素的线程会被阻塞，直到有元素被放入队列；与标准的 `BlockingQueue` 不同，这个队列的头部总是最小的元素。
4. **DelayQueue**： 一个支持延时获取元素的无界阻塞队列。只有在元素的延迟期满时，才能从队列中取到该元素。它通常用于缓存任务，这些任务在特定的延迟之后才能执行。
5. **SynchronousQueue**： 一个不存储元素的阻塞队列。每个插入操作必须等待一个相应的删除操作，反之亦然。也就是说，如果尝试向队列添加一个元素，但没有线程正在等待从队
6. 队列中移除元素，那么添加操作的线程会被阻塞，直到有线程来移除元素。同样，如果尝试从队列中移除元素，但没有元素可供移除，并且没有线程正在等待向队列中添加元素，那么移除操作的线程会被阻塞，直到有线程添加元素。

`BlockingQueue` 的底层实现依赖于具体的实现类。例如，`ArrayBlockingQueue` 使用数组作为其内部数据结构，并通过锁和其他同步机制来确保线程安全；`LinkedBlockingQueue` 则使用链表作为其内部数据结构，并使用内部类来管理锁的获取和释放，以实现线程间的同步。
