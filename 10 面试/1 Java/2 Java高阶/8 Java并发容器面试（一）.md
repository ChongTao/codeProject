# 1 BlockingQueue底层原理

`BlockingQueue` 是 Java 并发包 `java.util.concurrent` 中的一个接口，它表示一个由线程安全地访问的先进先出（FIFO）队列。这个队列被设计用来支持在并发编程中的线程同步。`BlockingQueue` 允许一个或多个线程等待队列变为非空（用于从队列中取出元素），或者允许一个或多个线程等待队列变为非满（用于向队列中插入元素）。这些等待操作会导致线程阻塞，直到其他线程执行相应的操作。

1. **ArrayBlockingQueue**： 一个由数组支持的有界阻塞队列。这个队列按照 FIFO（先进先出）的原则对元素进行排序。当队列为空时，获取元素的线程会被阻塞，直到有元素被放入队列；当队列已满时，尝试添加元素的线程会被阻塞，直到队列中有元素被取出。
2. **LinkedBlockingQueue**： 一个由链表支持的可选有界阻塞队列。如果创建时指定了容量，那么它就是一个有界队列；如果没有指定容量，那么它就是一个无界队列。与 `ArrayBlockingQueue` 类似，它也支持在队列为空时阻塞获取元素的线程，以及在队列满时阻塞添加元素的线程。
3. **PriorityBlockingQueue**： 一个支持优先级排序的无界阻塞队列。元素按照它们的自然排序或者通过提供的 `Comparator` 进行排序。当队列为空时，获取元素的线程会被阻塞，直到有元素被放入队列；与标准的 `BlockingQueue` 不同，这个队列的头部总是最小的元素。
4. **DelayQueue**： 一个支持延时获取元素的无界阻塞队列。只有在元素的延迟期满时，才能从队列中取到该元素。它通常用于缓存任务，这些任务在特定的延迟之后才能执行。
5. **SynchronousQueue**： 一个不存储元素的阻塞队列。每个插入操作必须等待一个相应的删除操作，反之亦然。也就是说，如果尝试向队列添加一个元素，但没有线程正在等待从队
6. 队列中移除元素，那么添加操作的线程会被阻塞，直到有线程来移除元素。同样，如果尝试从队列中移除元素，但没有元素可供移除，并且没有线程正在等待向队列中添加元素，那么移除操作的线程会被阻塞，直到有线程添加元素。

`BlockingQueue` 的底层实现依赖于具体的实现类。例如，`ArrayBlockingQueue` 使用数组作为其内部数据结构，并通过锁和其他同步机制来确保线程安全；`LinkedBlockingQueue` 则使用链表作为其内部数据结构，并使用内部类来管理锁的获取和释放，以实现线程间的同步。

# 2 ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？

`ArrayBlockingQueue` 和 `LinkedBlockingQueue` 是 Java 中两种常见的 `BlockingQueue` 实现，它们之间的主要区别体现在以下几个方面：

1. **底层数据结构**：

   - `ArrayBlockingQueue` 使用数组作为其底层数据结构，这个数组在创建时就被初始化，并确定了队列的容量。
   - `LinkedBlockingQueue` 使用链表作为其底层数据结构，可以是有界的（指定了容量）或无界的（没有指定容量）。

2. **队列大小**：

   - `ArrayBlockingQueue` 在创建时必须指定队列的大小，并且大小是固定的，不能更改。
   - `LinkedBlockingQueue` 在创建时可以指定容量，也可以不指定。如果不指定容量，那么它就是一个无界队列，可以容纳任意数量的元素。

3. **锁的实现**：

   - `ArrayBlockingQueue` 中的锁是没有分离的，即生产和消费操作使用的是同一个锁。这意味着在高并发场景下，生产和消费操作可能会互相阻塞，降低了并发性能。
   - `LinkedBlockingQueue` 中的锁是分离的，生产操作使用 `putLock`，消费操作使用 `takeLock`。这种分离的锁设计可以提高并发性能，允许生产者和消费者在高并发情况下并行操作队列中的数据。
   - **操作性能**：
     - `ArrayBlockingQueue` 在生产和消费时，直接将元素插入或移除数组。由于数组是连续的内存空间，这种操作相对较快。
     - `LinkedBlockingQueue` 在生产和消费时，需要把元素转换为 `Node<E>` 类型进行插入或移除，这涉及到对象的创建和销毁，因此性能上可能稍逊于 `ArrayBlockingQueue`。
   - **内存使用**：
     - `ArrayBlockingQueue` 由于使用的是数组，所以在插入或删除元素时不会产生或销毁任何额外的对象实例，内存使用效率较高。
     - `LinkedBlockingQueue` 在插入或删除元素时，会生成一个额外的 `Node` 对象，这会增加垃圾回收的压力，并可能影响内存使用效率。
   - **线程安全性**：
     - 两者都是线程安全的，因为它们都使用了适当的锁和同步机制来确保线程之间的正确交互。
   - **适用场景**：
     - `ArrayBlockingQueue` 由于其固定的大小和相对较高的性能，通常用于生产者-消费者场景中，其中生产者和消费者的速度相对均衡，并且队列的大小是已知的。
     - `LinkedBlockingQueue` 由于其可变的容量和分离的锁设计，通常用于生产者-消费者场景中，其中生产者和消费者的速度可能非常不均衡，或者当队列的大小需要动态调整时。

   在选择使用哪种队列时，应根据具体的应用场景、性能需求以及并发特性来进行权衡。



